<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>操作系统 on Example Site</title>
        <link>https://example.com/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/</link>
        <description>Recent content in 操作系统 on Example Site</description>
        <generator>Hugo -- gohugo.io</generator>
        <language>en</language>
        <copyright>Example Person</copyright>
        <lastBuildDate>Fri, 01 Aug 2025 21:50:00 +0800</lastBuildDate><atom:link href="https://example.com/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/index.xml" rel="self" type="application/rss+xml" /><item>
        <title>线程</title>
        <link>https://example.com/p/%E7%BA%BF%E7%A8%8B/</link>
        <pubDate>Fri, 01 Aug 2025 21:50:00 +0800</pubDate>
        
        <guid>https://example.com/p/%E7%BA%BF%E7%A8%8B/</guid>
        <description>&lt;h1 id=&#34;线程&#34;&gt;线程
&lt;/h1&gt;&lt;h2 id=&#34;相关概念&#34;&gt;相关概念
&lt;/h2&gt;&lt;h3 id=&#34;定义&#34;&gt;定义
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;定义：线程是独立的指令流，可以被内核调度运行&lt;/li&gt;
&lt;li&gt;进程包含的状态和资源
&lt;ul&gt;
&lt;li&gt;代码、堆、数据、文件句柄（包括套接字）、进程间通信（IPC）&lt;/li&gt;
&lt;li&gt;进程ID、进程组ID、用户ID&lt;/li&gt;
&lt;li&gt;栈、寄存器、程序计数器（PC）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;线程与进程关系
&lt;ul&gt;
&lt;li&gt;线程存在于进程内部，并共享进程的资源&lt;/li&gt;
&lt;li&gt;每个线程都有自己的核心资源（线程独有资源）
&lt;ul&gt;
&lt;li&gt;栈&lt;/li&gt;
&lt;li&gt;寄存器&lt;/li&gt;
&lt;li&gt;程序计数器&lt;/li&gt;
&lt;li&gt;线程特定数据&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;访问共享资源需要同步&lt;/li&gt;
&lt;li&gt;线程由内核独立调度&lt;/li&gt;
&lt;li&gt;每个线程都有自己独立的控制流&lt;/li&gt;
&lt;li&gt;每个线程都可以处于任何调度状态&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;线程的优势&#34;&gt;线程的优势
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;响应性：多线程交互应用程序允许程序即使在部分被阻塞或执行长时间操作时也能继续运行&lt;/li&gt;
&lt;li&gt;资源共享：资源共享可以实现高校通信和高度协作。线程默认共享进程的资源和内存。&lt;/li&gt;
&lt;li&gt;经济性：线程比进程更轻量级，创建和上下文切换的开销更小&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;多线程服务器架构&#34;&gt;多线程服务器架构
&lt;/h2&gt;&lt;h3 id=&#34;架构示意图&#34;&gt;架构示意图
&lt;/h3&gt; &lt;p align=&#34;center&#34;&gt;
    &lt;img src=&#34;https://example.com/images/thread1.png&#34; alt=&#34;server&#34; width=&#34;75%&#34;&gt;
&lt;/p&gt;
* 工作方式解释：server的主进程（一般是监听进程）接受客户端的请求，然后主进程创建一个新的线程来处理请求。之后主监听进程继续监听其他的客户端请求
&lt;h3 id=&#34;注并发与并行&#34;&gt;注：并发与并行
&lt;/h3&gt;&lt;h4 id=&#34;定义-1&#34;&gt;定义
&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;并发计算是一种计算形式，其中程序被设计为相互交互的计算进程集合，这些进程可以并行执行。并发程序（进程或线程）可以在单个处理器上通过时间片轮转的方式交错执行各自的执行步骤，也可以通过将每个计算进程分配给一组处理器来并行执行。程序作为独立执行进程的组合，这些进程相互通信。&lt;/li&gt;
&lt;li&gt;行计算是一种计算形式，其中许多计算同时进行，基于大问题通常可以分解为较小问题的原理，然后&amp;quot;并行&amp;quot;解决这些小问题。
编程作为（可能相关的）计算的同时执行&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;对比&#34;&gt;对比
&lt;/h4&gt;&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th&gt;维度&lt;/th&gt;
          &lt;th&gt;并发 (Concurrency)&lt;/th&gt;
          &lt;th&gt;并行 (Parallelism)&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;strong&gt;核心概念&lt;/strong&gt;&lt;/td&gt;
          &lt;td&gt;同一时间段内交替执行&lt;/td&gt;
          &lt;td&gt;同一时刻真正同时执行&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;strong&gt;硬件要求&lt;/strong&gt;&lt;/td&gt;
          &lt;td&gt;单核CPU即可&lt;/td&gt;
          &lt;td&gt;必须多核CPU或多台机器&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;strong&gt;设计思想&lt;/strong&gt;&lt;/td&gt;
          &lt;td&gt;如何组织和管理任务&lt;/td&gt;
          &lt;td&gt;如何真正同时计算&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;strong&gt;主要目的&lt;/strong&gt;&lt;/td&gt;
          &lt;td&gt;提高响应性、资源利用率&lt;/td&gt;
          &lt;td&gt;提高计算速度&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;h4 id=&#34;关键理解&#34;&gt;关键理解
&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;并发关乎结构，并行关乎执行&lt;/li&gt;
&lt;li&gt;并发提供了一种构建解决方案的方式来解决一个可能（但不一定）可并行化的问题&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;线程的实现&#34;&gt;线程的实现
&lt;/h2&gt;&lt;h3 id=&#34;基本信息&#34;&gt;基本信息
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;线程可以在用户级别或由内核提供&lt;/li&gt;
&lt;li&gt;用户线程在内核之上支持，无需内核支持即可管理
&lt;ul&gt;
&lt;li&gt;三个线程库：POSIX Pthreads、Win32线程和Java线程&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;内核线程由内核直接支持和管理
&lt;ul&gt;
&lt;li&gt;所有现代操作系统都支持内核线程&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;线程实现的方式&#34;&gt;线程实现的方式
&lt;/h3&gt;&lt;h4 id=&#34;内核级线程&#34;&gt;内核级线程
&lt;/h4&gt;&lt;h5 id=&#34;定义-2&#34;&gt;定义
&lt;/h5&gt;&lt;ul&gt;
&lt;li&gt;为了使并发更经济，进程的执行方面被分离为线程。因此，操作系统现在管理线程和进程。所有线程操作都在内核中实现，操作系统调度系统中的所有线程。由操作系统管理的线程成为内核级线程。&lt;/li&gt;
&lt;li&gt;在这种方法中，内核知道并管理线程。这种情况下不需要运行系统。内核不是在每个进程中保持线程表，而是拥有一个线程表来跟踪系统中的所有线程。此外，内核还维护传统的进程表来跟踪进程。操作系统内核提供系统调用来创建和管理线程。&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&#34;优势&#34;&gt;优势
&lt;/h5&gt;&lt;ul&gt;
&lt;li&gt;因为内核完全了解所有线程，调度器可能决定给拥有大量线程的进程分配更多时间，而不是给拥有少量线程的进程。&lt;/li&gt;
&lt;li&gt;内核级线程对于频繁阻塞的应用程序特别有效&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&#34;劣势&#34;&gt;劣势
&lt;/h5&gt;&lt;ul&gt;
&lt;li&gt;内核级线程速度慢而且效率低&lt;/li&gt;
&lt;li&gt;存在显著的开销和内核复杂性的增加&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;用户级线程&#34;&gt;用户级线程
&lt;/h4&gt;&lt;h5 id=&#34;定义-3&#34;&gt;定义
&lt;/h5&gt;&lt;ul&gt;
&lt;li&gt;用户级显示完全由运行时系统（用户级库）管理内核对用户级线程一无所知，将它们作为单线程进程管理。用户级线程小而快，每个线程由PC、寄存器、栈和小型线程控制块表示。创建新线程、线程间切换和线程同步都通过过程调用完成，即无内核参与。用户及线程比内核级线程块100倍。&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&#34;优势-1&#34;&gt;优势
&lt;/h5&gt;&lt;ul&gt;
&lt;li&gt;这种技术最明显的优势是用户级线程包可以在不支持的线程的操作系统上实现&lt;/li&gt;
&lt;li&gt;用户级线程不需要修改操作系统&lt;/li&gt;
&lt;li&gt;简单表示：每个线程简单地由PC、寄存器、栈和小型控制块表示，都存储在用户进程地址空间中&lt;/li&gt;
&lt;li&gt;简单管理：这意味着创建线程和线程间同步都可以在没有内核干预的情况下完成&lt;/li&gt;
&lt;li&gt;快速高效：线程切换比过程调用贵不了多少&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&#34;劣势-1&#34;&gt;劣势
&lt;/h5&gt;&lt;ul&gt;
&lt;li&gt;用户级线程不是完美解决方案，它们是一种权衡。由于用户级线程对操作系统不可见，它们与操作系统集成不好。结果是，操作系统可能做出糟糕决策，如调度有空闲线程的进程、阻塞启动I/O的线程所在的进程（即使该进程有其他可运行线程）、取消调度持有锁的线程所在的进程。解决者需要内核和用户级线程管理器之间的通信。&lt;/li&gt;
&lt;li&gt;线程和操作系统内核之间缺乏协调。因此，整个进程获得一个时间片，无论进程有一个线程还是1000个线程。每个线程都要主动放弃控制权给其他线程。&lt;/li&gt;
&lt;li&gt;用户级线程需要非阻塞调用，即多线程内核。，否则，整个进程将在内核中阻塞，即使进程中还有可运行的线程。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;多线程模型&#34;&gt;多线程模型
&lt;/h2&gt;&lt;h3 id=&#34;含义&#34;&gt;含义：
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;用户线程和内核线程之间必须存在关系&lt;/li&gt;
&lt;li&gt;内核线程是系统中真正的线程，所以为了使用户线程取得进展，用户程序必须让其调度器获取一个用户线程，然后再内核线程上运行它&lt;/li&gt;
&lt;li&gt;核心：只有内核线程真正在CPU上执行&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;多线程模型详解&#34;&gt;多线程模型详解
&lt;/h3&gt;&lt;h4 id=&#34;多对一模型many-to-one&#34;&gt;多对一模型(Many-to-one)
&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;多个用户级线程映射到单个内核线程&lt;/li&gt;
&lt;li&gt;线路管理由用户空间的线程库完成&lt;/li&gt;
&lt;li&gt;如果一个线程进程阻塞系统调用，整个进程将被阻塞&lt;/li&gt;
&lt;li&gt;将阻塞系统调用转换为非阻塞&lt;/li&gt;
&lt;li&gt;多个线程无法再多处理器上并行运行&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;一对一模型one-to-one&#34;&gt;一对一模型(One-to-one)
&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;每个用户级线程映射到一个内核线程&lt;/li&gt;
&lt;li&gt;允许其他线程在一个线程阻塞时运行&lt;/li&gt;
&lt;li&gt;多个线程可以在多处理器上并行运行&lt;/li&gt;
&lt;li&gt;总计金额导致开销&lt;/li&gt;
&lt;li&gt;大多数实现次模型的操作系统限制线程数量&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;多对多模型&#34;&gt;多对多模型
&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;许多用户级线程映射到许多内核线程&lt;/li&gt;
&lt;li&gt;解决了1:1和m:1模型的缺点&lt;/li&gt;
&lt;li&gt;开发人员可以创建必要数量的用户线程&lt;/li&gt;
&lt;li&gt;相应的内核线程可以在多处理器上并行运行&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;两级模型&#34;&gt;两级模型
&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;类似对于多对多模型，除了它允许用户线程绑定到内核线程&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;fork和exec的语义问题&#34;&gt;fork和exec的语义问题
&lt;/h3&gt;&lt;h4 id=&#34;fork&#34;&gt;fork
&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;当对单线程进程fork时，直接复制整个单线程进程&lt;/li&gt;
&lt;li&gt;当读多线程进程fork时，可以理解为只复制调用线程或复制所有线程，在UNIX中有两个版本的fork，每种语义一个&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;exec&#34;&gt;exec
&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;exec通常替换整个进程&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;fork与exec的综合使用&#34;&gt;fork与exec的综合使用
&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;如果在fork后很快调用exec，使用“fork调用线程版本”，不需要复制所有线程&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;信号处理&#34;&gt;信号处理
&lt;/h2&gt;&lt;h3 id=&#34;概念&#34;&gt;概念
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;信号在UNIX系统中用于通知进程发生了特定事件，遵循相同的模式&lt;/li&gt;
&lt;li&gt;信号由特定事件的发生而产生&lt;/li&gt;
&lt;li&gt;信号倍传递给进程&lt;/li&gt;
&lt;li&gt;一旦传递，信号必须被处理&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;原则&#34;&gt;原则
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;信号由两种信号处理程序之一处理：默认的或用户定义的&lt;/li&gt;
&lt;li&gt;每个信号都有默认处理程序，内核在处理信号时运行&lt;/li&gt;
&lt;li&gt;用户定义的信号处理程序可以覆盖默认的&lt;/li&gt;
&lt;li&gt;对于单线程，信号传递给进程&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;多线程环境下的信号处理&#34;&gt;多线程环境下的信号处理
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;信号可以是同步的（异常）或异步的（I/O）&lt;/li&gt;
&lt;li&gt;同步信号传递给引起信号的同一线程&lt;/li&gt;
&lt;li&gt;一部信号可以传递给
&lt;ul&gt;
&lt;li&gt;信号适用的线程&lt;/li&gt;
&lt;li&gt;进程中的每个线程&lt;/li&gt;
&lt;li&gt;进程中的某些线程（信号掩码）&lt;/li&gt;
&lt;li&gt;接收进程所有信号的特定线程&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;线程取消&#34;&gt;线程取消
&lt;/h2&gt;&lt;h3 id=&#34;概念-1&#34;&gt;概念
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;线程取消：在目标线程完成之前终止它&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;取消的实现方法&#34;&gt;取消的实现方法
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;异步取消：立即终止目标线程&lt;/li&gt;
&lt;li&gt;延迟取消：允许目标线程定期检查是否应该被取消&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;取消的实现细节&#34;&gt;取消的实现细节
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;调用线程取消请求取消，但是实际取消取决于线程状态&lt;/li&gt;
&lt;li&gt;如果线程禁用了取消，取消保持挂起状态直到线程启用它&lt;/li&gt;
&lt;li&gt;默认类型时延迟取消&lt;/li&gt;
&lt;li&gt;取消只在线程到达取消点时发生
&lt;ul&gt;
&lt;li&gt;即pthread_testcancel()&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;然后调用清理处理程序&lt;/li&gt;
&lt;li&gt;在Linux系统上，线程取消通过信号处理&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;线程特定数据thread-specifif-data&#34;&gt;线程特定数据(Thread Specifif Data)
&lt;/h2&gt;&lt;h3 id=&#34;线程特定数据&#34;&gt;线程特定数据
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;线程本地存储(TLS)允许每个线程拥有自己的数据副本&lt;/li&gt;
&lt;li&gt;当你无法控制线程创建过程时很有用（即使用线程池时）&lt;/li&gt;
&lt;li&gt;与局部变量不同&lt;/li&gt;
&lt;li&gt;局部变量只在单个函数调用期间可见&lt;/li&gt;
&lt;li&gt;TLS在函数调用间可见&lt;/li&gt;
&lt;li&gt;类似于静态数据&lt;/li&gt;
&lt;li&gt;TLS对每个线程都是唯一的&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;轻量级进程与调度器激活&#34;&gt;轻量级进程与调度器激活
&lt;/h2&gt;&lt;h3 id=&#34;轻量级进程概念&#34;&gt;轻量级进程概念
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;在计算机操作系统中，轻量级进程（LWP）是实现多任务的一种方式。在传统意义上，如Unix System V和Solaris中使用的术语，LWP在用户空间中运行在单个内核线程之上，并与同一进程内的其他LWP共享地址空间和系统资源。多个用户级线程由线程库管理，可以放置在一个或多个LWP之上——允许在用户级进行多任务处理，这可以带来一些性能优势&lt;/li&gt;
&lt;li&gt;在一些操作系统中，内核线程和用户线程之间没有单独的LWP层。这意味着用户线程直接在内核线程之上实现。在这些情况下，术语&amp;quot;轻量级进程&amp;quot;通常指内核线程，而术语&amp;quot;线程&amp;quot;可以指用户线程。在Linux上，用户线程通过允许某些进程共享资源来实现，这有时导致这些进程被称为&amp;quot;轻量级进程&amp;quot;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;调度方式&#34;&gt;调度方式
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;轻量级进程(LWP)是多对多和两级模型中用户线程和内核线程之间的中间数据集二狗&lt;/li&gt;
&lt;li&gt;对用户线程库来说，它看起来像虚拟处理器来调度用户线程&lt;/li&gt;
&lt;li&gt;每个LWP都连接到一个内核线程&lt;/li&gt;
&lt;li&gt;内核线程阻塞 -&amp;gt; LWP阻塞 -&amp;gt; 用户线程阻塞&lt;/li&gt;
&lt;li&gt;内核调度内核线程，线程库调度用户线程&lt;/li&gt;
&lt;li&gt;线程库可能做出次优的调度决策&lt;/li&gt;
&lt;li&gt;解决方案：让内核通知线程库的重要的调度事件&lt;/li&gt;
&lt;li&gt;调度器激活通过上调通知线程库&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;windos-xp线程&#34;&gt;Windos XP线程
&lt;/h2&gt;&lt;h3 id=&#34;概念-2&#34;&gt;概念
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;Windos XP实现一对一映射线程模型&lt;/li&gt;
&lt;li&gt;每个线程包含
&lt;ul&gt;
&lt;li&gt;线程ID&lt;/li&gt;
&lt;li&gt;处理器状态的寄存器集&lt;/li&gt;
&lt;li&gt;堵路的用户栈和内核栈&lt;/li&gt;
&lt;li&gt;私有数据存储区域&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;线程的主要数据结构包括
&lt;ul&gt;
&lt;li&gt;ETHREAD：执行线程块&lt;/li&gt;
&lt;li&gt;KTHREAD：内核线程块&lt;/li&gt;
&lt;li&gt;TEB：线程环境块&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;linux线程&#34;&gt;Linux线程
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;linux有fork和clone两个系统调用&lt;/li&gt;
&lt;li&gt;clone接收一组标志位，决定父进程和子进程之间的共享程度&lt;/li&gt;
&lt;li&gt;FS/VM/SIGHAND/FILES -&amp;gt; 相当于线程创建&lt;/li&gt;
&lt;li&gt;没有设置标志 -&amp;gt; 没有共享 -&amp;gt; 相当于fork&lt;/li&gt;
&lt;li&gt;Linux不区分进程和线程，使用术语“任务”而不是线程&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;线程库&#34;&gt;线程库
&lt;/h2&gt;&lt;h3 id=&#34;概念-3&#34;&gt;概念
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;线程库为程序员提供了创建和管理线程的API接口&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;两种主要实现方式&#34;&gt;两种主要实现方式
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;用户空间实现
&lt;ul&gt;
&lt;li&gt;完全在用户空间中实现，无需内核支持&lt;/li&gt;
&lt;li&gt;特点：快速、轻量级，但无法利用多核&lt;/li&gt;
&lt;li&gt;示例：早期的Green Threads&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;内核级实现
&lt;ul&gt;
&lt;li&gt;由操作系统支持的内核级库&lt;/li&gt;
&lt;li&gt;特点：可以真正并行，但开销较大&lt;/li&gt;
&lt;li&gt;示例：现代操作系统的标准实现&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;线程特性&#34;&gt;线程特性
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;线程拥有自己的身份标识，并且可以独立运行&lt;/li&gt;
&lt;li&gt;线程共享进程内的地址空间，享受避免任何进程间通信(IPC)通道（共享内存、管道等）进行通信的好处&lt;/li&gt;
&lt;li&gt;进程中的线程可以直接相互通信&lt;/li&gt;
&lt;li&gt;例如独立的线程可以访问/更新全局变量&lt;/li&gt;
&lt;li&gt;这种模型消除了内核本来需要承担的潜在IPC开销。由于线程在同一地址空间中，线程上下文切换是廉价且快速的&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;pthread调度&#34;&gt;Pthread调度
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;API允许在线程创建时指定PCS或SCS调度范围&lt;/li&gt;
&lt;li&gt;pthread_attr_set/getscope是相关的API&lt;/li&gt;
&lt;li&gt;PTHREAD_SCOPE_PROCESS：使用PCS调度来调度线程&lt;/li&gt;
&lt;li&gt;LWP的数量由线程库维护&lt;/li&gt;
&lt;li&gt;PTHREAD_SCOPE_SYSTEM：使用SCS调度来调度线程&lt;/li&gt;
&lt;li&gt;可用的调度范围可能受到操作系统的限制&lt;/li&gt;
&lt;li&gt;例如：Linux和Mac OS X只允许PTHREAD_SCOPE_SYSTEM&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;多处理器调度&#34;&gt;多处理器调度
&lt;/h2&gt;&lt;h3 id=&#34;多处理器架构类型&#34;&gt;多处理器架构类型
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;多处理器可能是以下任一架构
&lt;ul&gt;
&lt;li&gt;多核CPU&lt;/li&gt;
&lt;li&gt;多线程核心&lt;/li&gt;
&lt;li&gt;NUMA系统&lt;/li&gt;
&lt;li&gt;异构多处理&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;多处理器调度基础
&lt;ul&gt;
&lt;li&gt;当有多个CPU可用时，CPU调度变得更加复杂&lt;/li&gt;
&lt;li&gt;假设处理器在功能上时相同的（同构的）&lt;/li&gt;
&lt;li&gt;多处理器调度的方法
&lt;ul&gt;
&lt;li&gt;非对称多处理：
&lt;ul&gt;
&lt;li&gt;只有一个处理器做调度决策、I/O处理和其他活动&lt;/li&gt;
&lt;li&gt;其他处理器充当虚拟处理单元&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;对称多处理(SMP)：每个处理器都是自调度的
&lt;ul&gt;
&lt;li&gt;调度数据结构是共享的，需要同步&lt;/li&gt;
&lt;li&gt;被通用操作系统使用&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;SMP架构细节
&lt;ul&gt;
&lt;li&gt;对称多处理(SMP)是每个处理器都自调度的架构&lt;/li&gt;
&lt;li&gt;所有线程可能在一个公共就绪队列中(a)&lt;/li&gt;
&lt;li&gt;或者每个处理器可能有自己的私有线程队列(b)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;多核调度
&lt;ul&gt;
&lt;li&gt;单芯片中的多个CPU核心&lt;/li&gt;
&lt;li&gt;最近的趋势是在同一物理芯片上防止多个处理器核心，更快且功耗更低&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;芯片多线程(CMT)
&lt;ul&gt;
&lt;li&gt;多线程核心：芯片多线程&lt;/li&gt;
&lt;li&gt;Intel使用超线程术语（或同时多线程-SMT）：在同一核心上同时运行两个（或更多）硬件线程：内存停顿&lt;/li&gt;
&lt;li&gt;利用内存停顿在内存检索时在另一个线程上取得进展&lt;/li&gt;
&lt;li&gt;每个核心有&amp;gt;1个硬件线程。如果一个线程有内存停顿，切换到另一个线程！&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;CMT的两级调度
&lt;ul&gt;
&lt;li&gt;两级调度：
&lt;ul&gt;
&lt;li&gt;操作系统决定在逻辑CPU上运行哪个软件线程&lt;/li&gt;
&lt;li&gt;每个核心如何决定在物理核心上运行哪个硬件线程。两个硬件线程不能并行运行，因为我们只有一个CPU核心&lt;/li&gt;
&lt;li&gt;如果操作系统知道CPU资源的底层共享情况，可以做出更好的决策&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;负载均衡
&lt;ul&gt;
&lt;li&gt;如果是SMP，需要保持所有CPU的负载以提高效率&lt;/li&gt;
&lt;li&gt;负载均衡试图保持工作负载均匀分布&lt;/li&gt;
&lt;li&gt;推送迁移 - 周期性任务检查每个处理器的负载，如果发现则将任务从过载的CPU推送到其他CPU&lt;/li&gt;
&lt;li&gt;拉取迁移 - 空闲处理器从繁忙处理器拉取等待任务&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;处理器亲和性
&lt;ul&gt;
&lt;li&gt;当线程在一个处理器上运行时，该处理器的缓存内容存储该线程的内存访问&lt;/li&gt;
&lt;li&gt;我们称这为线程对处理器有亲和性（即&amp;quot;处理器亲和性&amp;quot;）&lt;/li&gt;
&lt;li&gt;负载均衡可能影响处理器亲和性，因为线程可能从一个处理器移动到另一个处理器以平衡负载，但该线程失去了在其移出的处理器缓存中的内容&lt;/li&gt;
&lt;li&gt;软亲和性 - 操作系统试图保持线程在同一处理器上运行，但不保证&lt;/li&gt;
&lt;li&gt;硬亲和性 - 允许进程指定一组它可以运行的处理器&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;NUMA和CPU调度
&lt;ul&gt;
&lt;li&gt;如果操作系统是NUMA感知的，它将分配靠进展线程运行CPU的内存&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;实时CPU调度
&lt;ul&gt;
&lt;li&gt;可能出现明显的挑战&lt;/li&gt;
&lt;li&gt;软实时系统-关键实时任务有最高优先级，但不保证任务何时被调度&lt;/li&gt;
&lt;li&gt;硬实时系统-任务必须在其截止时间前得到服务&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;linux-2623-完全公平调度器cfs详解&#34;&gt;Linux 2.6.23+ 完全公平调度器(CFS)详解
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;Linux调度器版本2.6.23+
&lt;ul&gt;
&lt;li&gt;完全公平调度器(CFS)&lt;/li&gt;
&lt;li&gt;调度类&lt;/li&gt;
&lt;li&gt;每个调度类都有特定的优先级&lt;/li&gt;
&lt;li&gt;调度器选择最高优先级调度类中的最高优先级任务&lt;/li&gt;
&lt;li&gt;不是基于固定时间分配的量子，而是基于CPU时间比例(nice值)&lt;/li&gt;
&lt;li&gt;较少的nice值将获得更高比例的CPU时间&lt;/li&gt;
&lt;li&gt;包含2个调度类，其他可以添加
&lt;ul&gt;
&lt;li&gt;默认调度类&lt;/li&gt;
&lt;li&gt;实时调度类&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;CFS量子计算细节
&lt;ul&gt;
&lt;li&gt;量子基于nice值计算，从-20到+19&lt;/li&gt;
&lt;li&gt;较低的值是更高的优先级&lt;/li&gt;
&lt;li&gt;计算目标延迟 - 任务应该至少运行一次的时间间隔&lt;/li&gt;
&lt;li&gt;如果活跃任务数量增加，目标延迟可以增加&lt;/li&gt;
&lt;li&gt;CFS调度器在变量vruntime中维护每个任务的虚拟运行时间&lt;/li&gt;
&lt;li&gt;与基于任务优先级的衰减因子相关联 - 较低优先级有较高的衰减率&lt;/li&gt;
&lt;li&gt;正常默认优先级产生虚拟运行时间 = 实际运行时间&lt;/li&gt;
&lt;li&gt;要决定下一个运行的任务，调度器选择虚拟运行时间最低的任务&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;linux调度系统补充详解&#34;&gt;Linux调度系统补充详解
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;Linux实时调度
&lt;ul&gt;
&lt;li&gt;根据POSIX.1b标准的实时调度&lt;/li&gt;
&lt;li&gt;实时任务具有静态优先级&lt;/li&gt;
&lt;li&gt;实时任务加上普通任务映射到全局优先级方案&lt;/li&gt;
&lt;li&gt;Nice值-20映射到全局优先级100&lt;/li&gt;
&lt;li&gt;Nice值+19映射到优先级139&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Linux负载均衡与NUMA
&lt;ul&gt;
&lt;li&gt;Linux支持负载均衡，但也是NUMA感知的&lt;/li&gt;
&lt;li&gt;调度域是一组可以相互平衡的CPU核心集合&lt;/li&gt;
&lt;li&gt;域按它们共享的内容（即缓存内存）组织。目标是防止线程在域之间迁移&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;windows调度系统详解&#34;&gt;Windows调度系统详解
&lt;/h3&gt;&lt;h4 id=&#34;windows调度基础&#34;&gt;Windows调度基础
&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;Windows使用基于优先级的抢占式调度&lt;/li&gt;
&lt;li&gt;最高优先级的线程下一个运行&lt;/li&gt;
&lt;li&gt;调度器就是分发器(Dispatcher)&lt;/li&gt;
&lt;li&gt;线程运行直到 (1)阻塞，(2)用完时间片，(3)被更高优先级线程抢占&lt;/li&gt;
&lt;li&gt;实时线程可以抢占非实时线程&lt;/li&gt;
&lt;li&gt;32级优先级方案：可变类是1-15，实时类是16-31&lt;/li&gt;
&lt;li&gt;优先级0是内存管理线程&lt;/li&gt;
&lt;li&gt;每个优先级一个队列&lt;/li&gt;
&lt;li&gt;如果没有可运行线程，运行空闲线程&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;windows优先级类&#34;&gt;Windows优先级类
&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;不同的优先级类&lt;/li&gt;
&lt;/ul&gt;
</description>
        </item>
        <item>
        <title>调度</title>
        <link>https://example.com/p/%E8%B0%83%E5%BA%A6/</link>
        <pubDate>Fri, 01 Aug 2025 21:50:00 +0800</pubDate>
        
        <guid>https://example.com/p/%E8%B0%83%E5%BA%A6/</guid>
        <description>&lt;h1 id=&#34;调度&#34;&gt;调度
&lt;/h1&gt;&lt;h2 id=&#34;调度术语&#34;&gt;调度术语
&lt;/h2&gt;&lt;h3 id=&#34;术语辨析&#34;&gt;术语辨析
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;被操作系统调度的是内核线程————而不是进程&lt;/li&gt;
&lt;li&gt;然而，“线程调度”和“进程调度”这两个属于经常互换使用&lt;/li&gt;
&lt;li&gt;当讨论一般概念时我们使用“进程调度”，当设计线程特定概念时使用“线程调度”&lt;/li&gt;
&lt;li&gt;同时“在CPU上运行”实际是指在“CPU核心上运行”&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;注cpu与cpu核心&#34;&gt;注：CPU与CPU核心
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;CPU可以包含多个核心。何以把CPU比作一座办公大楼，CPU核心是一个办公室，正在执行的线程就是一个正在工作的员工&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;进程调度&#34;&gt;进程调度
&lt;/h2&gt;&lt;h3 id=&#34;基本概念&#34;&gt;基本概念
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;进程执行由CPU执行和I/O等待的循环组成&lt;/li&gt;
&lt;li&gt;CPU突发和I/O突发交替进行&lt;/li&gt;
&lt;li&gt;CPU突发分布在进程间和计算机间差异很大，但遵循相似的曲线&lt;/li&gt;
&lt;li&gt;通过多道程序设计获得最大的CPU利用率&lt;/li&gt;
&lt;li&gt;当前进程处于I/O突发时，CPU调度器选择另一个进程&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;cpu调度器&#34;&gt;CPU调度器
&lt;/h3&gt;&lt;h4 id=&#34;调度决策选择&#34;&gt;调度决策选择
&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;CPU调度器从就绪队列中的进程中进行选择，并将CPU分配给其中一个进程&lt;/li&gt;
&lt;li&gt;CPU调度决策可能在一下情况发生
&lt;ul&gt;
&lt;li&gt;进程从运行状态切换到等待状态&lt;/li&gt;
&lt;li&gt;进程从运行状态切换到就绪状态&lt;/li&gt;
&lt;li&gt;进程从等待状态切换到就绪状态&lt;/li&gt;
&lt;li&gt;进程终止&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;仅在条件1和4下的调度是非抢占式的
&lt;ul&gt;
&lt;li&gt;一旦CPU被分配给进程，该进程会保持CPU直到终止或等待I/O&lt;/li&gt;
&lt;li&gt;也被称为协作式调度&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;抢占式调度还会在条件2和3下调度进程
&lt;ul&gt;
&lt;li&gt;抢占式调度需要硬件支持，如定时器&lt;/li&gt;
&lt;li&gt;需要同步原语&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;注协作式调度与抢占式调度&#34;&gt;注：协作式调度与抢占式调度
&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;协作式调度：自觉排队
&lt;ul&gt;
&lt;li&gt;基本思想：没有管理员的机房，每个人用完电脑后主动让给下一个人，程序自己决定什么时候停下来并主动分享资源&lt;/li&gt;
&lt;li&gt;什么时候让出CPU
&lt;ul&gt;
&lt;li&gt;程序需要读写文件时（I/O）&lt;/li&gt;
&lt;li&gt;程序主动调用sleep休眠&lt;/li&gt;
&lt;li&gt;程序运行完毕退出&lt;/li&gt;
&lt;li&gt;程序主动调用yield让出&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;抢占式调度：由管理员的排队
&lt;ul&gt;
&lt;li&gt;核心思想：有管理员的机房，管理员用定时器控制每个人的使用时间，到了时间就必须让出&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;什么时候强制切换
&lt;ul&gt;
&lt;li&gt;时间片用完&lt;/li&gt;
&lt;li&gt;有更高优先级的程序要运行&lt;/li&gt;
&lt;li&gt;程序进行I/O操作时&lt;/li&gt;
&lt;li&gt;程序运行完毕&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;抢占&#34;&gt;抢占
&lt;/h3&gt;&lt;h4 id=&#34;内核抢占&#34;&gt;内核抢占
&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;抢占也会影响系统内核的设计&lt;/li&gt;
&lt;li&gt;如果在更新共享数据时被抢占，内核状态将会不一致&lt;/li&gt;
&lt;li&gt;即当中断发生时内核正在服务系统调用&lt;/li&gt;
&lt;li&gt;两种解决方案
&lt;ul&gt;
&lt;li&gt;等待系统调用完成或I/O阻塞&lt;/li&gt;
&lt;li&gt;内核时非抢占式的，但对进程仍然是抢占式的&lt;/li&gt;
&lt;li&gt;在更新共享数据时禁用内核抢占&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;最新的Linux内核采用这种方法
&lt;ul&gt;
&lt;li&gt;Linux支持SMP&lt;/li&gt;
&lt;li&gt;共享数据受内核同步保护&lt;/li&gt;
&lt;li&gt;在内核同步时禁用内核抢占&lt;/li&gt;
&lt;li&gt;将非抢占式SMP内核转变为抢占式内核&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;用户抢占和内核抢占的具体时机&#34;&gt;用户抢占和内核抢占的具体时机
&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;用户抢占
&lt;ul&gt;
&lt;li&gt;从系统调用返回用户空间时&lt;/li&gt;
&lt;li&gt;从中断处理程序返回用户空间时&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;内核抢占
&lt;ul&gt;
&lt;li&gt;当中断处理程序退出，返回内核空间之前&lt;/li&gt;
&lt;li&gt;当内核代码重新变为可抢占时&lt;/li&gt;
&lt;li&gt;如果内核中的任务显示调用schedule()&lt;/li&gt;
&lt;li&gt;如果内核中的任务阻塞（这会导致调用schedule）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;分派器dispatcher&#34;&gt;分派器(Dispatcher)
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;分派器模块将CPU的控制权交给由段齐调度器选中的进程&lt;/li&gt;
&lt;li&gt;切换上下文&lt;/li&gt;
&lt;li&gt;切换到用户模式&lt;/li&gt;
&lt;li&gt;跳转到用户程序中的正确位置以重启该程序&lt;/li&gt;
&lt;li&gt;分派延迟：分派其停止一个进程并启动另一个进程所需的时间&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;调度标准&#34;&gt;调度标准
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;CPU利用率：CPU忙碌的百分比&lt;/li&gt;
&lt;li&gt;吞吐量：每个事件单位内完成执行的进程数量&lt;/li&gt;
&lt;li&gt;周转时间：执行特定进程的事件
&lt;ul&gt;
&lt;li&gt;从提交时间到完成时间&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;等待时间：在就绪队列中等待的总时间&lt;/li&gt;
&lt;li&gt;相应时间：从请求提交到产生第一个相应所需的时间
&lt;ul&gt;
&lt;li&gt;开始相应所需的时间&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;调度算法优化标准&#34;&gt;调度算法优化标准
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;一般来说，最大化CPU利用率和吞吐率，最小化周转时间、等待时间和响应时间&lt;/li&gt;
&lt;li&gt;不同系统优化不同的值&lt;/li&gt;
&lt;li&gt;在多数情况下优化平均值&lt;/li&gt;
&lt;li&gt;在某些情况下，优化最小值或最大值
&lt;ul&gt;
&lt;li&gt;例如：实时系统&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;对于交互式系统，最小化响应时间的方差&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;调度算法&#34;&gt;调度算法
&lt;/h3&gt;&lt;h4 id=&#34;先来先服务调度fcfs&#34;&gt;先来先服务调度(FCFS)
&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;总结：排队买票&lt;/li&gt;
&lt;li&gt;核心思想：谁先来谁先服务，就像银行排队一样&lt;/li&gt;
&lt;li&gt;工作原理
&lt;ul&gt;
&lt;li&gt;按照进程到达的先后顺序执行&lt;/li&gt;
&lt;li&gt;第一个到达当地的进程先执行完，在执行第二个，以此类推&lt;/li&gt;
&lt;li&gt;一旦开始执行就不会被打断&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;优点：公平、简单、不会饥饿&lt;/li&gt;
&lt;li&gt;缺点：短任务可能等很久（护航效应）&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;最短作业优先调整sjf&#34;&gt;最短作业优先调整(SJF)
&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;总结：快餐优先&lt;/li&gt;
&lt;li&gt;核心思想：总是先做最快能完成的任务&lt;/li&gt;
&lt;li&gt;工作原理：
&lt;ul&gt;
&lt;li&gt;在所有等待的进程中，选择执行时间最短的执行&lt;/li&gt;
&lt;li&gt;可以大幅减少平均等待时间&lt;/li&gt;
&lt;li&gt;需要事先知道每个进程要执行多长时间&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;优点：平均等待时间最短（理论最优）&lt;/li&gt;
&lt;li&gt;缺点：长任务可能永远轮不到（饥饿问题）&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;优先级调度priority&#34;&gt;优先级调度(Priority)
&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;核心思想：重要的任务先做&lt;/li&gt;
&lt;li&gt;工作原理：
&lt;ul&gt;
&lt;li&gt;每个进程都有一个优先级数字&lt;/li&gt;
&lt;li&gt;总是选择优先级最高的进程执行&lt;/li&gt;
&lt;li&gt;可以根据重要性动态调整优先级&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;老化机制：为了防止普通顾客永远等不到，可以让等待时间长的客户逐渐升级&lt;/li&gt;
&lt;li&gt;优点：体现重要性，灵活可控&lt;/li&gt;
&lt;li&gt;缺点：低优先级可能饥饿，需要防饥饿机制&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;时间片轮转调度round-robin&#34;&gt;时间片轮转调度(Round Robin)
&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;核心思想：轮流服务&lt;/li&gt;
&lt;li&gt;工作原理：
&lt;ul&gt;
&lt;li&gt;给每个进程分配相同的时间片&lt;/li&gt;
&lt;li&gt;时间到了就强制切换到下一个进程&lt;/li&gt;
&lt;li&gt;没完成的进程重新排队等下一轮&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;优点：响应时间好，公平，适合交互式系统&lt;/li&gt;
&lt;li&gt;缺点：频繁切换有开销，时间片大小难选择&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;多级队列调度mlq&#34;&gt;多级队列调度(MLQ)
&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;核心思想：分类服务&lt;/li&gt;
&lt;li&gt;工作原理
&lt;ul&gt;
&lt;li&gt;把进程分成几个固定的类别（系统进程、前台进程、后台进程等）&lt;/li&gt;
&lt;li&gt;每个类别有自己的队列和调度策略&lt;/li&gt;
&lt;li&gt;高优先级队列优先服务&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;优点：不同类型用最适合的策略，系统进程优先&lt;/li&gt;
&lt;li&gt;缺点：底层队列可能饥饿，分类可能不准确&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;多级反馈队列调度mlfq&#34;&gt;多级反馈队列调度(MLFQ)
&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;核心思想：根据客户的行为表现动态调整服务等级&lt;/li&gt;
&lt;li&gt;工作原理：
&lt;ul&gt;
&lt;li&gt;新进程从最高优先级队列开始&lt;/li&gt;
&lt;li&gt;如果用完时间片还没完成，就降级到下一级队列&lt;/li&gt;
&lt;li&gt;如果主动让出CPU（比如等待I/O），可能提升等级&lt;/li&gt;
&lt;li&gt;等待太久的进程会自动升级（防止饥饿）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;优点：最只能，自适应，段任务响应快，长任务不饥饿&lt;/li&gt;
&lt;li&gt;缺点：最复杂，参数调整困难，实现开销大&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;mlq详解&#34;&gt;MLQ详解
&lt;/h4&gt;&lt;h5 id=&#34;多级队列调度&#34;&gt;多级队列调度
&lt;/h5&gt;&lt;ul&gt;
&lt;li&gt;多级队列调度
&lt;ul&gt;
&lt;li&gt;就绪队列被分割为多个独立的队列&lt;/li&gt;
&lt;li&gt;例如：前台（交互式）进程和后台（批处理）进程&lt;/li&gt;
&lt;li&gt;进程被永久分配到指定的队列&lt;/li&gt;
&lt;li&gt;每个队列都有自己的调度算法&lt;/li&gt;
&lt;li&gt;例如：交互式进程使用RR，批处理进程使用FCFS&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;队列间调度
&lt;ul&gt;
&lt;li&gt;必须子啊队列之间进行调度&lt;/li&gt;
&lt;li&gt;固定优先级调度&lt;/li&gt;
&lt;li&gt;存在饥饿的可能性&lt;/li&gt;
&lt;li&gt;时间片分配：每个队列获得一定数量的CPU时间，用于在其进程之间进行调度&lt;/li&gt;
&lt;li&gt;例如：前台进程80%时间用RR，后台进程20%时间用FCFS&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;多级反馈队列
&lt;ul&gt;
&lt;li&gt;多级反馈队列调度使用多级队列&lt;/li&gt;
&lt;li&gt;进程可以在不同队列之间移动&lt;/li&gt;
&lt;li&gt;它试图推断进程的类型&lt;/li&gt;
&lt;li&gt;老化机制可以通过这种方式实现&lt;/li&gt;
&lt;li&gt;目标时给交互式和I/O密集型进程高优先级&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;MLFQ定义参数
&lt;ul&gt;
&lt;li&gt;MLFQ调度器由以下参数定义&lt;/li&gt;
&lt;li&gt;队列数量&lt;/li&gt;
&lt;li&gt;每个队列的调度算法&lt;/li&gt;
&lt;li&gt;确定何时给进程分配更高优先级的方法&lt;/li&gt;
&lt;li&gt;确定何时降级进程的方法&lt;/li&gt;
&lt;li&gt;确定进程需要服务时进入那个队列的方法&lt;/li&gt;
&lt;li&gt;MLFQ是最通用的CPU调度算法&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;线程调度&#34;&gt;线程调度
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;操作系统内核调度内核线程&lt;/li&gt;
&lt;li&gt;系统竞争范围 (SCS)：系统中所有线程之间的竞争&lt;/li&gt;
&lt;li&gt;内核不知道用户线程的存在&lt;/li&gt;
&lt;li&gt;线程库将用户线程调度到LWP上&lt;/li&gt;
&lt;li&gt;用于多对一和多对多线程模型&lt;/li&gt;
&lt;li&gt;进程竞争范围 (PCS)：进程内部的调度竞争&lt;/li&gt;
&lt;li&gt;PCS通常基于用户设置的优先级&lt;/li&gt;
&lt;li&gt;被调度到LWP的用户线程不一定在CPU上运行&lt;/li&gt;
&lt;li&gt;操作系统内核需要将LWP的内核线程调度到CPU上&lt;/li&gt;
&lt;/ul&gt;
</description>
        </item>
        <item>
        <title>进程</title>
        <link>https://example.com/p/%E8%BF%9B%E7%A8%8B/</link>
        <pubDate>Fri, 01 Aug 2025 21:50:00 +0800</pubDate>
        
        <guid>https://example.com/p/%E8%BF%9B%E7%A8%8B/</guid>
        <description>&lt;h1 id=&#34;进程&#34;&gt;进程
&lt;/h1&gt;&lt;h2 id=&#34;进程的概念&#34;&gt;进程的概念
&lt;/h2&gt;&lt;h3 id=&#34;进程与程序&#34;&gt;进程与程序
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;一个操作系统可以运行许多个程序，一个运行中的程序被称为&lt;strong&gt;进程(Process)&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;进程与程序的关系：
&lt;ul&gt;
&lt;li&gt;程序是被动和静态的，进程是主动和动态的&lt;/li&gt;
&lt;li&gt;一个程序对应的可能有多个进程&lt;/li&gt;
&lt;li&gt;程序可以通过GUI或命令行启动&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;进程的组成&#34;&gt;进程的组成
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;程序代码
&lt;ul&gt;
&lt;li&gt;内容：可执行的程序指令&lt;/li&gt;
&lt;li&gt;特点：只读，多个相同进程可以共享同一份代码&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;运行时CPU状态
&lt;ul&gt;
&lt;li&gt;程序技术去(PC): 指向下一条要执行的指令地址&lt;/li&gt;
&lt;li&gt;寄存器组：
&lt;ul&gt;
&lt;li&gt;通用寄存器：存储计算数据&lt;/li&gt;
&lt;li&gt;状态寄存器：保存处理器状态标志&lt;/li&gt;
&lt;li&gt;专用寄存器：如栈指针、基址寄存器等&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;内存区域
&lt;ul&gt;
&lt;li&gt;栈(Stack)&lt;/li&gt;
&lt;li&gt;数据段(Data Section)&lt;/li&gt;
&lt;li&gt;堆(Heap)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;进程的状态state&#34;&gt;进程的状态(State)
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;一个进程包含以下状态
&lt;ul&gt;
&lt;li&gt;new&lt;/li&gt;
&lt;li&gt;running&lt;/li&gt;
&lt;li&gt;wating/blocking&lt;/li&gt;
&lt;li&gt;ready&lt;/li&gt;
&lt;li&gt;terminated&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;状态转换示意图&lt;/li&gt;
&lt;/ul&gt;
&lt;p align=&#34;center&#34;&gt;
    &lt;img src=&#34;https://example.com/images/process1.png&#34; alt=&#34;State&#34; width=&#34;80%&#34;&gt;
&lt;/p&gt;
&lt;h3 id=&#34;进程控制块process-control-block-pcb&#34;&gt;进程控制块(Process Control Block, PCB)
&lt;/h3&gt;&lt;h4 id=&#34;基本概念&#34;&gt;基本概念
&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;PCB是操作系统管理进程的核心数据结构，每个进程都有唯一的PCB&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;pcb的四大类信息&#34;&gt;PCB的四大类信息、
&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;进程标识信息
&lt;ul&gt;
&lt;li&gt;PID：进程唯一标识符&lt;/li&gt;
&lt;li&gt;PPID：父进程ID&lt;/li&gt;
&lt;li&gt;UID/GID：用户和组标识符&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;处理机状态信息
&lt;ul&gt;
&lt;li&gt;程序计数器(PC)：下一条指令地址&lt;/li&gt;
&lt;li&gt;寄存器组：CPU寄存器的值&lt;/li&gt;
&lt;li&gt;栈指针：当前栈位置&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;进程调度信息：
&lt;ul&gt;
&lt;li&gt;优先级：调度优先级&lt;/li&gt;
&lt;li&gt;进程状态：运行/就绪/阻塞等&lt;/li&gt;
&lt;li&gt;CPU时间：已使用和分配的时间&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;进程控制信息
&lt;ul&gt;
&lt;li&gt;内存管理：页表、内存映射&lt;/li&gt;
&lt;li&gt;文件管理：打开的文件列表&lt;/li&gt;
&lt;li&gt;信号处理：信号处理机制&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;pcb的关键作用&#34;&gt;PCB的关键作用
&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;上下文切换
&lt;ul&gt;
&lt;li&gt;保存当前进程状态到PCB，然后从PCB恢复目标进程状态&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;进程管理
&lt;ul&gt;
&lt;li&gt;创建：分配新PCB&lt;/li&gt;
&lt;li&gt;调度：基于PCB信息选择进程&lt;/li&gt;
&lt;li&gt;终止：释放PCB和相关资源&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;资源跟踪
&lt;ul&gt;
&lt;li&gt;内存分配情况&lt;/li&gt;
&lt;li&gt;打开的文件&lt;/li&gt;
&lt;li&gt;拥有的设备&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;pcb在linux中的实现-task_struct&#34;&gt;PCB在linux中的实现: task_struct
&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;Linux使用task_struct结构体实现PCB，包含：
&lt;ul&gt;
&lt;li&gt;进程状态和标识&lt;/li&gt;
&lt;li&gt;内存管理信息(mm_struct)&lt;/li&gt;
&lt;li&gt;文件系统信息(files_struct)&lt;/li&gt;
&lt;li&gt;父子进程关系&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;PCB在系统中的组织
&lt;ul&gt;
&lt;li&gt;进程链表：所有进程形成链表&lt;/li&gt;
&lt;li&gt;哈希表：通过PID快速查找&lt;/li&gt;
&lt;li&gt;运行队列：就绪进程的调度队列&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;线程thread&#34;&gt;线程(Thread)
&lt;/h3&gt;&lt;h2 id=&#34;进程调度&#34;&gt;进程调度
&lt;/h2&gt;&lt;h3 id=&#34;调度&#34;&gt;调度
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;CPU调度器会选择接下来要运行的进程并分配内存。这个操作一般是非常快的&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;调度队列&#34;&gt;调度队列
&lt;/h3&gt;&lt;h4 id=&#34;定义&#34;&gt;定义
&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;操作系统内核用来组织和管理不同状态进程的数据结构，是实现搞笑进程调度的基础。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;三种主要调度队列&#34;&gt;三种主要调度队列
&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;作业队列(Job Queue)
&lt;ul&gt;
&lt;li&gt;范围：系统中的所有进程&lt;/li&gt;
&lt;li&gt;用途：全局管理和统计&lt;/li&gt;
&lt;li&gt;对应命令：ps aux&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;就绪队列(Ready Queue)
&lt;ul&gt;
&lt;li&gt;范围：准备执行的进程&lt;/li&gt;
&lt;li&gt;特点：按优先级组织，支持快速选择&lt;/li&gt;
&lt;li&gt;实现：多级队列 + 位图索引&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;设备队列(Device Queue)
&lt;ul&gt;
&lt;li&gt;范围：等待I/O的进程&lt;/li&gt;
&lt;li&gt;分类：磁盘、网络、键盘等不同设备&lt;/li&gt;
&lt;li&gt;状态：TASK_INTERRUPTIBLE/UNINTERRUPTIBLE&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;上下文切换context-switch&#34;&gt;上下文切换(Context Switch)
&lt;/h3&gt;&lt;h4 id=&#34;定义-1&#34;&gt;定义
&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;内核切换到另一个进程去执行，保存就进程的状态并加载新进程的已保存状态&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;开销&#34;&gt;开销
&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;上下文切换是开销，CPU在切换时不做任何有用的工作。操作系统和PCB越复杂，上下文切换时间越长，时间取决于硬件支持。某些硬件为每个CPU提供多组寄存器，可以同时加载多个上下文&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;进程创建&#34;&gt;进程创建
&lt;/h3&gt;&lt;h4 id=&#34;概念&#34;&gt;概念
&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;父进程可以创建子进程，子进程可以进一步创建子进程，形成进程树。进程通过进程标识符(PID)来识别和管理&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;design-choices&#34;&gt;Design choices
&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;三种可能的资源共享级别：全部、子集、无&lt;/li&gt;
&lt;li&gt;父进程和子进程的地址空间管理
&lt;ul&gt;
&lt;li&gt;子进程复制父进程地址空间(Linux)&lt;/li&gt;
&lt;li&gt;子进程加载新程序(Windows)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;父进程和子进程的执行
&lt;ul&gt;
&lt;li&gt;父进程和子进程并发执行&lt;/li&gt;
&lt;li&gt;父进程等待子进程终止&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;用于进程创建的系统调用&#34;&gt;用于进程创建的系统调用
&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;fork: 创建一个新的进程副本，结束时会返回&lt;/li&gt;
&lt;li&gt;exec: 使用一个新的进程的地址覆盖当前进程地址，加载了新程序，不会返回原程序&lt;/li&gt;
&lt;li&gt;wait: 阻塞直到子进程结束&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;进程终止&#34;&gt;进程终止
&lt;/h3&gt;&lt;h4 id=&#34;工作流程&#34;&gt;工作流程
&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;正常终止：进程执行最后一条语句并请求内核删除它(exit)
&lt;ul&gt;
&lt;li&gt;操作系统将子进程的返回值传递给父进程(wait)&lt;/li&gt;
&lt;li&gt;进程的资源被操作系统释放&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;异常终止：父进程可能终止子进程的执行(abort)
&lt;ul&gt;
&lt;li&gt;子进程超出了分配到的资源&lt;/li&gt;
&lt;li&gt;分配给子进程的任务不在被需要&lt;/li&gt;
&lt;li&gt;如果父进程退出，一些操作系统不允许子进程继续
&lt;ul&gt;
&lt;li&gt;所有子进程（整个子树）将被终止-这被称为&lt;strong&gt;级联终止(cascading termination)&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;注exit与_exit&#34;&gt;注：exit与_exit
&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;exit为标准库函数，执行终止进程和清理&lt;/li&gt;
&lt;li&gt;_exit为系统调用，直接请求内核终止进程，不做清理&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;可能存在的错误僵尸进程与孤儿进程&#34;&gt;可能存在的错误————僵尸进程与孤儿进程
&lt;/h4&gt;&lt;h5 id=&#34;僵尸进程&#34;&gt;僵尸进程
&lt;/h5&gt;&lt;ul&gt;
&lt;li&gt;僵尸进程时已经执行完毕但父进程还没有回收其退出状态的子进程&lt;/li&gt;
&lt;li&gt;特征
&lt;ul&gt;
&lt;li&gt;进程已死亡：不再执行任何代码&lt;/li&gt;
&lt;li&gt;PCB仍存在：内核保留进程控制块&lt;/li&gt;
&lt;li&gt;保存退出状态：等待父进程读取&lt;/li&gt;
&lt;li&gt;不占用内存：代码段、数据段、栈都释放&lt;/li&gt;
&lt;li&gt;占用PID槽位：PID不能被其他进程使用&lt;/li&gt;
&lt;li&gt;ps显示为&amp;lt;defunct&amp;gt;：状态标记为Z&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&#34;孤儿进程&#34;&gt;孤儿进程
&lt;/h5&gt;&lt;ul&gt;
&lt;li&gt;孤儿进程是父进程已经退出，但子进程仍然在运行的进程&lt;/li&gt;
&lt;li&gt;特征
&lt;ul&gt;
&lt;li&gt;仍在运行：进程仍然正常执行&lt;/li&gt;
&lt;li&gt;父进程变更：PPID变为1（init进程）&lt;/li&gt;
&lt;li&gt;正常运行：功能不受影响&lt;/li&gt;
&lt;li&gt;自动回收：退出时由init进程回收&lt;/li&gt;
&lt;li&gt;通常无害：不会造成资源泄漏&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&#34;关键区别&#34;&gt;关键区别
&lt;/h5&gt;&lt;ul&gt;
&lt;li&gt;僵尸进程是管理问题，有害，大量积累会耗尽系统资源，需要程序员解决&lt;/li&gt;
&lt;li&gt;孤儿进程是自然现象，无害，系统自动解决&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;android进程&#34;&gt;Android进程
&lt;/h3&gt;&lt;h4 id=&#34;android进程重要性层次结构&#34;&gt;Android进程重要性层次结构
&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;移动操作系统经常需要终止进程来回收系统资源（如内存）。按重要性从高到低排列
&lt;ul&gt;
&lt;li&gt;前台进程：在屏幕上可见
&lt;ul&gt;
&lt;li&gt;用户正在使用微信&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;可见进程：不直接可见，但执行前台进程正在引用的活动
&lt;ul&gt;
&lt;li&gt;视频应用播放时弹出权限对话框&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;服务进程：如流媒体音乐
&lt;ul&gt;
&lt;li&gt;音乐应用后台播放&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;后台进程：执行活动，但用户不明显感知
&lt;ul&gt;
&lt;li&gt;用户切换应用后原应用进入后台&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;空进程：不包含任何活动&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Android将开始终止最不重要的进程&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;浏览器的多进程架构&#34;&gt;浏览器的多进程架构
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;在过去许多网页浏览器作为单一进程运行（有些仍然如此）。这会导致如果一个网站出现问题，整个浏览器都可能挂起或崩溃&lt;/li&gt;
&lt;li&gt;Google Chrome浏览器采用多进程架构，包含3中不同类型的进程：
&lt;ul&gt;
&lt;li&gt;浏览器进程：管理用户界面、磁盘和网络I/O&lt;/li&gt;
&lt;li&gt;渲染进程：渲染网页，处理HTML、Javascript。为每个打开的网页创建新的渲染进程&lt;/li&gt;
&lt;li&gt;运行在沙箱中，限制磁盘和网络I/O,最小化安全漏洞的影响&lt;/li&gt;
&lt;li&gt;插件进程：为每种类型的插件创建进程&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;进程间通信&#34;&gt;进程间通信
&lt;/h3&gt;&lt;h4 id=&#34;概念-1&#34;&gt;概念
&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;系统中的进程可能是独立的或协作的
&lt;ul&gt;
&lt;li&gt;独立进程：无法影响或被其他进程的执行所影响的进程&lt;/li&gt;
&lt;li&gt;协作进程：可以影响或被其他进程影响的进程，包括共享数据&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;协作进程的原因：信息共享、计算加速、模块化、便利性、安全性&lt;/li&gt;
&lt;li&gt;写作进程需要进程间通信(IPC)&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;ipc模型&#34;&gt;IPC模型
&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;存在两种IPC模型：
&lt;ul&gt;
&lt;li&gt;共享内存&lt;/li&gt;
&lt;li&gt;消息传递&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;示意图：
  &lt;p align=&#34;center&#34;&gt;
      &lt;img src=&#34;https://example.com/images/process2.png&#34; alt=&#34;IPC&#34; width=&#34;70%&#34;&gt;
  &lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;生产者-消费者问题&#34;&gt;生产者-消费者问题
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;协作进程的范例，生产者进程产生信息，被消费者进程消费&lt;/li&gt;
&lt;li&gt;无界缓冲区：对缓冲区大小没有实际限制&lt;/li&gt;
&lt;li&gt;有界缓冲区：假设有固定的缓冲区大小&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;消息传递&#34;&gt;消息传递
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;进程通过交换消息互相通信&lt;/li&gt;
&lt;li&gt;无需依赖共享变量&lt;/li&gt;
&lt;li&gt;消息传递提供两个操作
&lt;ul&gt;
&lt;li&gt;send：发送消息&lt;/li&gt;
&lt;li&gt;receive：接受消息&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;如果P和Q希望通信，它们需要
&lt;ul&gt;
&lt;li&gt;在它们之间建立通信链路&lt;/li&gt;
&lt;li&gt;例如：邮箱(间接)或基于pid(直接)&lt;/li&gt;
&lt;li&gt;通过send/receive交换消息&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;直接与间接通信
&lt;ul&gt;
&lt;li&gt;直接通信
&lt;ul&gt;
&lt;li&gt;对称寻址: send(P, Message), receive(Q, Message)&lt;/li&gt;
&lt;li&gt;非对称寻址: send(P, message), receive(id, Message)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;间接通信
&lt;ul&gt;
&lt;li&gt;send(A, Message), receive(A, Message) -邮箱A&lt;/li&gt;
&lt;li&gt;邮箱可以由进程和操作系统实现&lt;/li&gt;
&lt;li&gt;邮箱所有者：谁可以接收消息&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;同步机制
&lt;ul&gt;
&lt;li&gt;消息传递可以是阻塞的或非阻塞的&lt;/li&gt;
&lt;li&gt;阻塞被认为是同步的
&lt;ul&gt;
&lt;li&gt;阻塞发送：发送者阻塞直到消息被接收&lt;/li&gt;
&lt;li&gt;阻塞接收：接收者阻塞直到有消息可用&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;非阻塞被认为是异步的
&lt;ul&gt;
&lt;li&gt;非阻塞发送：发送者发送消息后继续执行&lt;/li&gt;
&lt;li&gt;非阻塞接收：接收者接收有效消息或返回空值&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;缓冲机制
&lt;ul&gt;
&lt;li&gt;附加到链路的消息队列&lt;/li&gt;
&lt;li&gt;零容量：0条消息
&lt;ul&gt;
&lt;li&gt;发送者必须等待接收者&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;有些容量：有线长度的n条消息
&lt;ul&gt;
&lt;li&gt;如果链路满，发送者必须等待&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;误解容量：无限长度
&lt;ul&gt;
&lt;li&gt;发送者永不等待&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;posix共享内存&#34;&gt;POSIX共享内存
&lt;/h3&gt;&lt;h4 id=&#34;概念-2&#34;&gt;概念
&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;进程首先创建共享内存段&lt;/li&gt;
&lt;li&gt;也用于打开现有的内存段&lt;/li&gt;
&lt;li&gt;设置对象的大小&lt;/li&gt;
&lt;li&gt;使用mmap()将文件指针内存映射到共享内存对象&lt;/li&gt;
&lt;li&gt;对共享内存的督学通过mmap()返回的指针完成&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;管道&#34;&gt;管道
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;管道作为一个通道，允许两个本地进程通信&lt;/li&gt;
&lt;li&gt;关键问题
&lt;ul&gt;
&lt;li&gt;通信是单向的还是双向的？&lt;/li&gt;
&lt;li&gt;在双向通信的情况下，是半双工还是全双工？&lt;/li&gt;
&lt;li&gt;进程之间是否必须存在关系（即父子关系）？&lt;/li&gt;
&lt;li&gt;管道是否可以在网络上使用？&lt;/li&gt;
&lt;li&gt;通常只用于本地进程&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;普通管道
&lt;ul&gt;
&lt;li&gt;普通管道允许生产者-消费者风格的通信&lt;/li&gt;
&lt;li&gt;生产者写入一端&lt;/li&gt;
&lt;li&gt;消费者从另一端读取&lt;/li&gt;
&lt;li&gt;因此普通管道是单向的&lt;/li&gt;
&lt;li&gt;如果需要双向通信，需要两个管道&lt;/li&gt;
&lt;li&gt;要求通信进程之间有父子关系&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;命名管道
&lt;ul&gt;
&lt;li&gt;命名管道比普通管道更强大&lt;/li&gt;
&lt;li&gt;通信是双向的&lt;/li&gt;
&lt;li&gt;进程之间不需要父子关系&lt;/li&gt;
&lt;li&gt;多个进程可以使用命名管道进行通信&lt;/li&gt;
&lt;li&gt;命名管道在UNIX和Windows系统上都有提供&lt;/li&gt;
&lt;li&gt;在Linux上，它被称为FIFO&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;客户端-用户交互&#34;&gt;客户端-用户交互
&lt;/h3&gt;&lt;h4 id=&#34;套接字socket&#34;&gt;套接字(Socket)
&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;套接字被定义为通信的端点&lt;/li&gt;
&lt;li&gt;IP地址和端口的连接&lt;/li&gt;
&lt;li&gt;套接字 161.25.19.8:1625 指的是主机 161.25.19.8 上的端口 1625&lt;/li&gt;
&lt;li&gt;通信在一对套接字之间进行&lt;/li&gt;
&lt;/ul&gt;
</description>
        </item>
        <item>
        <title>操作系统</title>
        <link>https://example.com/p/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/</link>
        <pubDate>Wed, 30 Jul 2025 21:40:00 +0800</pubDate>
        
        <guid>https://example.com/p/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/</guid>
        <description>&lt;h1 id=&#34;操作系统&#34;&gt;操作系统
&lt;/h1&gt;&lt;h2 id=&#34;基本信息介绍&#34;&gt;基本信息介绍
&lt;/h2&gt;&lt;h3 id=&#34;操作系统信息&#34;&gt;操作系统信息
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;在经典的五级结构划分中，计算机组成结构包含&lt;strong&gt;数字逻辑层&lt;/strong&gt;、&lt;strong&gt;微体系结构层&lt;/strong&gt;、&lt;strong&gt;指令集架构层&lt;/strong&gt;、&lt;strong&gt;操作系统层&lt;/strong&gt;、&lt;strong&gt;应用程序层&lt;/strong&gt;。其中前三层属于&amp;quot;硬件层&amp;quot;，最后一层属于&amp;quot;软件层&amp;quot;。操作系统的地位就是硬件和软件之间的媒介。扮演资源分配器和控制程序的角色。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;计算机系统的四个组成部分&#34;&gt;计算机系统的四个组成部分
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;硬件(Hardware)&lt;/strong&gt;：提供基本的计算资源
&lt;ul&gt;
&lt;li&gt;CPU、内存、I/O设备等&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;操作系统(Operating System)&lt;/strong&gt;：控制和协调硬件在用户之间的使用
&lt;ul&gt;
&lt;li&gt;资源分配器：管理所有资源，决定冲突请求的处理以实现高效和公平的资源共享&lt;/li&gt;
&lt;li&gt;控制程序：控制程序执行以防止错误和系统的不当使用&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;应用程序(Application Programs)&lt;/strong&gt;：使用系统资源解决计算问题
&lt;ul&gt;
&lt;li&gt;如文字处理器、编译器、Web浏览器等&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;用户(Users)&lt;/strong&gt;：
&lt;ul&gt;
&lt;li&gt;人、机器、其他计算机等&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;操作系统定义与视角&#34;&gt;操作系统定义与视角
&lt;/h3&gt;&lt;h4 id=&#34;用户视角-vs-系统视角&#34;&gt;用户视角 vs 系统视角
&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;用户视角&lt;/strong&gt;：
&lt;ul&gt;
&lt;li&gt;用户需要便利性和易用性&lt;/li&gt;
&lt;li&gt;不太关心资源利用率&lt;/li&gt;
&lt;li&gt;共享计算机（如主机）必须让所有用户满意&lt;/li&gt;
&lt;li&gt;手持设备资源受限，优化可用性和电池寿命&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;系统视角&lt;/strong&gt;：
&lt;ul&gt;
&lt;li&gt;操作系统是资源分配器&lt;/li&gt;
&lt;li&gt;操作系统是控制程序&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;操作系统定义&#34;&gt;操作系统定义
&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;近似定义&lt;/strong&gt;：&amp;ldquo;当你订购操作系统时，供应商提供的所有东西&amp;rdquo;
&lt;ul&gt;
&lt;li&gt;没有普遍接受的定义&lt;/li&gt;
&lt;li&gt;供应商提供的内容可能差异很大&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;内核(Kernel)&lt;/strong&gt;：&amp;ldquo;始终在计算机上运行的一个程序&amp;rdquo;
&lt;ul&gt;
&lt;li&gt;其他都是系统程序或应用程序&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;操作系统在不同上下文中可能有不同含义&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id=&#34;计算机系统组成&#34;&gt;计算机系统组成
&lt;/h2&gt;&lt;h3 id=&#34;硬件组件&#34;&gt;硬件组件
&lt;/h3&gt;&lt;h4 id=&#34;基本结构&#34;&gt;基本结构
&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;CPU和设备控制器&lt;/strong&gt;通过总线连接共享内存&lt;/li&gt;
&lt;li&gt;CPU和设备&lt;strong&gt;并发执行&lt;/strong&gt;，竞争内存周期&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;设备控制器&#34;&gt;设备控制器
&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;每个设备控制器负责特定类型的设备
&lt;ul&gt;
&lt;li&gt;磁盘控制器、USB控制器等&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;每个设备控制器都有&lt;strong&gt;本地缓冲区&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;I/O过程&lt;/strong&gt;：在设备和控制器本地缓冲区之间进行&lt;/li&gt;
&lt;li&gt;CPU在主内存和控制器缓冲区之间移动数据&lt;/li&gt;
&lt;li&gt;I/O设备和CPU可以&lt;strong&gt;并发执行&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;直接内存访问dma&#34;&gt;直接内存访问(DMA)
&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;用途&lt;/strong&gt;：用于能够以接近内存速度传输信息的高速I/O设备
&lt;ul&gt;
&lt;li&gt;如以太网、硬盘、CD-ROM等&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;工作流程&lt;/strong&gt;：
&lt;ol&gt;
&lt;li&gt;设备驱动程序向控制器发送I/O描述符&lt;/li&gt;
&lt;li&gt;I/O描述符包含：操作类型、内存地址等&lt;/li&gt;
&lt;li&gt;控制器在其本地缓冲区和主内存之间传输数据块，无需CPU干预&lt;/li&gt;
&lt;li&gt;整个I/O请求完成时只产生一个中断&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;中断与陷阱&#34;&gt;中断与陷阱
&lt;/h3&gt;&lt;h4 id=&#34;中断与陷阱讲解&#34;&gt;中断与陷阱讲解
&lt;/h4&gt;&lt;h5 id=&#34;中断interrupt&#34;&gt;中断（Interrupt）
&lt;/h5&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;定义&lt;/strong&gt;：中断是由外部硬件设备产生的异步事件，用来通知CPU某个事件已经发生&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;特点&lt;/strong&gt;：
&lt;ul&gt;
&lt;li&gt;异步发生：不可预知的时间点&lt;/li&gt;
&lt;li&gt;由外部硬件触发（如键盘输入、鼠标点击、网络数据到达等）&lt;/li&gt;
&lt;li&gt;CPU可以选择性地响应或屏蔽某些中断&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;类型&lt;/strong&gt;：
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;硬件中断&lt;/strong&gt;：由硬件设备产生（如定时器中断、I/O完成中断）&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;软件中断&lt;/strong&gt;：由软件指令产生（如系统调用）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;处理流程&lt;/strong&gt;：
&lt;ol&gt;
&lt;li&gt;硬件检测到中断信号&lt;/li&gt;
&lt;li&gt;CPU完成当前指令执行&lt;/li&gt;
&lt;li&gt;保存当前程序状态（寄存器、程序计数器等）&lt;/li&gt;
&lt;li&gt;跳转到中断服务程序（ISR）&lt;/li&gt;
&lt;li&gt;执行中断处理&lt;/li&gt;
&lt;li&gt;恢复被中断程序的状态&lt;/li&gt;
&lt;li&gt;继续执行被中断的程序&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&#34;陷阱trap&#34;&gt;陷阱（Trap）
&lt;/h5&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;定义&lt;/strong&gt;：陷阱是由正在执行的程序内部产生的同步事件&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;特点&lt;/strong&gt;：
&lt;ul&gt;
&lt;li&gt;同步发生：在特定指令执行时产生&lt;/li&gt;
&lt;li&gt;由当前执行的程序触发&lt;/li&gt;
&lt;li&gt;通常用于系统调用和异常处理&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;类型&lt;/strong&gt;：
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;系统调用陷阱&lt;/strong&gt;：用户程序请求操作系统服务&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;异常陷阱&lt;/strong&gt;：程序执行错误（如除零错误、非法内存访问等）&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;调试陷阱&lt;/strong&gt;：用于程序调试（如断点）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;处理流程&lt;/strong&gt;：
&lt;ol&gt;
&lt;li&gt;程序执行特定指令（如系统调用指令）&lt;/li&gt;
&lt;li&gt;CPU立即响应陷阱&lt;/li&gt;
&lt;li&gt;切换到内核模式&lt;/li&gt;
&lt;li&gt;跳转到相应的陷阱处理程序&lt;/li&gt;
&lt;li&gt;执行系统服务或异常处理&lt;/li&gt;
&lt;li&gt;返回用户模式（如果适用）&lt;/li&gt;
&lt;li&gt;继续执行程序&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&#34;中断与陷阱的区别&#34;&gt;中断与陷阱的区别
&lt;/h5&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;触发源&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;中断：外部硬件设备&lt;/li&gt;
&lt;li&gt;陷阱：程序内部指令&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;时机&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;中断：异步，不可预测&lt;/li&gt;
&lt;li&gt;陷阱：同步，可预测&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;用途&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;中断：处理外部事件，提高系统响应性&lt;/li&gt;
&lt;li&gt;陷阱：实现系统调用，处理程序异常&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;可屏蔽性&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;中断：部分可屏蔽&lt;/li&gt;
&lt;li&gt;陷阱：通常不可屏蔽&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&#34;重要性&#34;&gt;重要性
&lt;/h5&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;提高系统效率&lt;/strong&gt;：避免CPU空等，实现并发处理&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;实现系统调用&lt;/strong&gt;：用户程序与内核通信的桥梁&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;错误处理&lt;/strong&gt;：及时处理程序运行时错误&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;实时响应&lt;/strong&gt;：确保系统能够及时响应外部事件&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;操作系统对中断的处理&#34;&gt;操作系统对中断的处理
&lt;/h4&gt;&lt;h5 id=&#34;中断处理机制&#34;&gt;中断处理机制
&lt;/h5&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;中断向量表(Interrupt Vector Table)&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;存储中断服务程序入口地址的表格&lt;/li&gt;
&lt;li&gt;每个中断类型对应一个终端号和处理程序地址&lt;/li&gt;
&lt;li&gt;通常位于内存的固定位置&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;中断优先级&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;可屏蔽中断(Maskable Interrupt)&lt;/strong&gt;：可以被CPU忽略或延迟处理&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;不可屏蔽中断(Non-Maskable Interrupt, NMI)&lt;/strong&gt;：必须立即处理的紧急中断&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;优先级排序&lt;/strong&gt;：高优先级中断可以打断低优先级中断的处理&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&#34;中断处理步骤&#34;&gt;中断处理步骤
&lt;/h5&gt;&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;中断识别&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;硬件产生中断信号&lt;/li&gt;
&lt;li&gt;CUPU在每个指令周期结束时检查中断请求&lt;/li&gt;
&lt;li&gt;确定中断源和中断类型】&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;现场保护&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;自动保存：CPU自动保存程序状态字&lt;/li&gt;
&lt;li&gt;手动保存：中断服务程序保存其他寄存器内容&lt;/li&gt;
&lt;li&gt;保存到内核栈或进程控制块&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;中断分发&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;根据中断号查找中断向量表&lt;/li&gt;
&lt;li&gt;跳转到对应的中断服务程序(ISR)&lt;/li&gt;
&lt;li&gt;切换到内核模式（如果尚未切换）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;中断处理&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;执行具体的中断服务代码&lt;/li&gt;
&lt;li&gt;处理硬件设备的请求&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;现场恢复&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;恢复之前保存的寄存器内容&lt;/li&gt;
&lt;li&gt;恢复程序状态字和程序计数器&lt;/li&gt;
&lt;li&gt;返回被中断的程序继续执行&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h6 id=&#34;中断处理策略&#34;&gt;中断处理策略
&lt;/h6&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;立即处理（Immediate Processing）&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;中断发生时立即处理&lt;/li&gt;
&lt;li&gt;适用于紧急和高优先级中断&lt;/li&gt;
&lt;li&gt;可能影响系统响应时间&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;延迟处理（Deferred Processing）&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;将中断处理分为上半部和下半部&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;上半部&lt;/strong&gt;：快速处理紧急部分，清除中断源&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;下半部&lt;/strong&gt;：延后处理耗时的非紧急部分&lt;/li&gt;
&lt;li&gt;Linux中的软中断（softirq）和工作队列（workqueue）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;中断合并（Interrupt Coalescing）&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;将多个相同类型的中断合并处理&lt;/li&gt;
&lt;li&gt;减少中断处理开销&lt;/li&gt;
&lt;li&gt;提高系统吞吐量&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h6 id=&#34;中断控制器&#34;&gt;中断控制器
&lt;/h6&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;可编程中断控制器（PIC）&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;管理多个中断源&lt;/li&gt;
&lt;li&gt;设置中断优先级&lt;/li&gt;
&lt;li&gt;屏蔽特定中断&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;高级可编程中断控制器（APIC）&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;支持多处理器系统&lt;/li&gt;
&lt;li&gt;提供更灵活的中断路由&lt;/li&gt;
&lt;li&gt;支持中断重定向和负载均衡&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h6 id=&#34;现代操作系统的优化&#34;&gt;现代操作系统的优化
&lt;/h6&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;中断线程化&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;将中断处理程序作为内核线程运行&lt;/li&gt;
&lt;li&gt;提高系统的实时性和可预测性&lt;/li&gt;
&lt;li&gt;便于调试和性能分析&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;中断亲和性（Interrupt Affinity）&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;将特定中断绑定到特定CPU核心&lt;/li&gt;
&lt;li&gt;提高缓存利用率和性能&lt;/li&gt;
&lt;li&gt;减少处理器间通信开销&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;动态中断分配&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;根据系统负载动态调整中断处理&lt;/li&gt;
&lt;li&gt;实现负载均衡&lt;/li&gt;
&lt;li&gt;适应不同的工作负载模式&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h3 id=&#34;io&#34;&gt;I/O
&lt;/h3&gt;&lt;h4 id=&#34;io基本介绍&#34;&gt;I/O基本介绍
&lt;/h4&gt;&lt;h5 id=&#34;从系统调用到设备的io过程&#34;&gt;从系统调用到设备的I/O过程
&lt;/h5&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;系统调用访问&lt;/strong&gt;：程序使用系统调用访问系统资源
&lt;ul&gt;
&lt;li&gt;如文件、网络等&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;设备访问转换&lt;/strong&gt;：操作系统将其转换为设备访问并发出I/O请求&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;I/O请求传输&lt;/strong&gt;：I/O请求发送到设备驱动程序，然后到控制器
&lt;ul&gt;
&lt;li&gt;如读取磁盘块、发送/接收数据包等&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;等待处理&lt;/strong&gt;：
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;同步I/O&lt;/strong&gt;：OS让程序等待&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;异步I/O&lt;/strong&gt;：OS不等待直接返回给程序&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;进程切换&lt;/strong&gt;：当请求者等待时，OS可能切换到另一个程序&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;I/O完成&lt;/strong&gt;：I/O完成后控制器中断OS&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;处理结果&lt;/strong&gt;：
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;同步I/O&lt;/strong&gt;：OS处理I/O然后唤醒程序&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;异步I/O&lt;/strong&gt;：OS发送信号给程序&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&#34;中断驱动的io循环&#34;&gt;中断驱动的I/O循环
&lt;/h5&gt;&lt;ul&gt;
&lt;li&gt;操作系统通常是&lt;strong&gt;中断驱动&lt;/strong&gt;的&lt;/li&gt;
&lt;li&gt;中断传输控制到中断服务程序&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;中断向量&lt;/strong&gt;：包含所有服务程序地址的表格&lt;/li&gt;
&lt;li&gt;在服务另一个中断时，传入的中断被禁用以防止中断丢失&lt;/li&gt;
&lt;li&gt;中断处理程序必须保存（被中断的）执行状态&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;中断处理详细流程&#34;&gt;中断处理详细流程
&lt;/h4&gt;&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;中断识别&lt;/strong&gt;：
&lt;ul&gt;
&lt;li&gt;硬件产生中断信号&lt;/li&gt;
&lt;li&gt;CPU在每个指令周期结束时检查中断请求&lt;/li&gt;
&lt;li&gt;确定中断源和中断类型&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;现场保护&lt;/strong&gt;：
&lt;ul&gt;
&lt;li&gt;操作系统保存CPU的执行状态&lt;/li&gt;
&lt;li&gt;保存寄存器和程序计数器(PC)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;中断分发&lt;/strong&gt;：
&lt;ul&gt;
&lt;li&gt;OS确定哪个设备造成了中断&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;轮询(Polling)&lt;strong&gt;或&lt;/strong&gt;向量中断系统&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;中断处理&lt;/strong&gt;：
&lt;ul&gt;
&lt;li&gt;OS通过调用设备驱动程序处理中断&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;现场恢复&lt;/strong&gt;：
&lt;ul&gt;
&lt;li&gt;OS将CPU执行恢复到保存的状态&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;
&lt;h3 id=&#34;存储结构&#34;&gt;存储结构
&lt;/h3&gt;&lt;h4 id=&#34;存储层次结构&#34;&gt;存储层次结构
&lt;/h4&gt;&lt;h5 id=&#34;主存储器&#34;&gt;主存储器
&lt;/h5&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;主内存&lt;/strong&gt;：CPU能够直接访问的唯一大容量存储
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;随机访问&lt;/strong&gt;，通常是&lt;strong&gt;易失性&lt;/strong&gt;的&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;辅助存储&lt;/strong&gt;：大容量非易失性存储
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;磁盘&lt;/strong&gt;是最常见的辅助存储设备(HDD)&lt;/li&gt;
&lt;li&gt;由覆盖磁性记录材料的刚性金属或玻璃盘片组成&lt;/li&gt;
&lt;li&gt;磁盘表面逻辑上分为&lt;strong&gt;磁道&lt;/strong&gt;和&lt;strong&gt;扇区&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;磁盘控制器决定OS和设备之间的交互&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&#34;存储系统层次结构&#34;&gt;存储系统层次结构
&lt;/h5&gt;&lt;p&gt;存储系统可以按层次组织，考虑以下因素：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;速度(Speed)&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;成本(Cost)&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;易失性(Volatility)&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;存储性能层次（从快到慢）&lt;/strong&gt;：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;CPU寄存器&lt;/li&gt;
&lt;li&gt;CPU缓存(L1/L2/L3)&lt;/li&gt;
&lt;li&gt;主内存(RAM)&lt;/li&gt;
&lt;li&gt;辅助存储(SSD/HDD)&lt;/li&gt;
&lt;li&gt;光学存储/磁带&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;
&lt;h3 id=&#34;缓存&#34;&gt;缓存
&lt;/h3&gt;&lt;h4 id=&#34;缓存基本概念&#34;&gt;缓存基本概念
&lt;/h4&gt;&lt;h5 id=&#34;缓存原理&#34;&gt;缓存原理
&lt;/h5&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;缓存&lt;/strong&gt;：将信息复制到更快存储系统中&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;主内存&lt;/strong&gt;可以看作是辅助存储的缓存&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;CPU缓存&lt;/strong&gt;是主内存的缓存&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;缓存是在多个级别执行的重要原理&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;硬件、操作系统、用户程序等&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&#34;缓存工作机制&#34;&gt;缓存工作机制
&lt;/h5&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;数据复制&lt;/strong&gt;：使用中的数据从较慢存储临时复制到较快存储&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;缓存检查&lt;/strong&gt;：首先检查较快存储(缓存)以确定数据是否存在&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;缓存命中&lt;/strong&gt;：如果在缓存中，直接从缓存使用数据(快速)&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;缓存未命中&lt;/strong&gt;：如果不在缓存中，先将数据复制到缓存然后使用&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;缓存特点&lt;/strong&gt;：缓存通常比被缓存的存储小&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&#34;缓存管理&#34;&gt;缓存管理
&lt;/h5&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;缓存管理&lt;/strong&gt;是重要的设计问题
&lt;ul&gt;
&lt;li&gt;缓存大小&lt;/li&gt;
&lt;li&gt;替换策略&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;多任务环境&lt;/strong&gt;必须小心使用最新值，无论它存储在存储层次的哪里&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;多处理器环境&lt;/strong&gt;必须在硬件中提供缓存一致性，确保所有CPU在其缓存中都有最新值&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;虚拟缓存-vs-物理缓存&#34;&gt;虚拟缓存 vs 物理缓存
&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;虚拟缓存&lt;/strong&gt;：使用虚拟地址进行缓存&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;物理缓存&lt;/strong&gt;：使用物理地址进行缓存&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;缓存一致性&lt;/strong&gt;：多处理器必须保证缓存一致性&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h3 id=&#34;计算机系统架构&#34;&gt;计算机系统架构
&lt;/h3&gt;&lt;h4 id=&#34;系统分类&#34;&gt;系统分类
&lt;/h4&gt;&lt;p&gt;根据通用处理器数量分类：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;单处理器系统&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;多处理器系统&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;单处理器系统&#34;&gt;单处理器系统
&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;大多数老系统只有一个通用处理器
&lt;ul&gt;
&lt;li&gt;如智能手机、PC、服务器、主机&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;大多数系统也有专用处理器&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;多处理器系统&#34;&gt;多处理器系统
&lt;/h4&gt;&lt;h5 id=&#34;基本特征&#34;&gt;基本特征
&lt;/h5&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;别名&lt;/strong&gt;：并行系统、紧耦合系统&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;优势&lt;/strong&gt;：
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;增加吞吐量&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;规模经济&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;增加可靠性&lt;/strong&gt;：优雅降级或容错&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&#34;多处理器类型&#34;&gt;多处理器类型
&lt;/h5&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;非对称多处理(Asymmetric Multiprocessing)&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;对称多处理(SMP, Symmetric Multiprocessing)&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;多核设计&#34;&gt;多核设计
&lt;/h4&gt;&lt;h5 id=&#34;多核-vs-超线程&#34;&gt;多核 vs 超线程
&lt;/h5&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;多核&lt;/strong&gt;：单个芯片中多个CPU核心&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;超线程&lt;/strong&gt;：两个程序可以同时使用一个执行单元(在一个核心内)&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;性能依赖&lt;/strong&gt;：操作系统、编译器、应用程序&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&#34;numa架构&#34;&gt;NUMA架构
&lt;/h5&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;非统一内存访问系统(Non-Uniform Memory Access)&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;本地内存访问快速&lt;/strong&gt;，可扩展性好&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;集群系统&#34;&gt;集群系统
&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;多个系统&lt;/strong&gt;通过高速网络协同工作&lt;/li&gt;
&lt;li&gt;通常通过**存储区域网络(SAN)**共享存储&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;高可用性服务&lt;/strong&gt;，可以在故障中生存&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;非对称集群&lt;/strong&gt;：一台机器处于热备用模式&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;对称集群&lt;/strong&gt;：多个节点运行应用程序，相互监控&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;高性能计算(HPC)&lt;/strong&gt;：应用程序必须编写以使用并行化&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;分布式系统&#34;&gt;分布式系统
&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;独立系统集合&lt;/strong&gt;，可能是异构的，通过网络互连&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;网络OS&lt;/strong&gt;允许系统交换消息&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;分布式系统&lt;/strong&gt;创建单一系统的错觉&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;特殊用途系统&#34;&gt;特殊用途系统
&lt;/h4&gt;&lt;h5 id=&#34;实时嵌入式系统&#34;&gt;实时嵌入式系统
&lt;/h5&gt;&lt;ul&gt;
&lt;li&gt;最普遍的计算机形式&lt;/li&gt;
&lt;li&gt;变化很大&lt;/li&gt;
&lt;li&gt;使用特殊用途(有限用途)实时OS&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&#34;多媒体系统&#34;&gt;多媒体系统
&lt;/h5&gt;&lt;ul&gt;
&lt;li&gt;数据流必须根据时间限制传送&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&#34;手持系统&#34;&gt;手持系统
&lt;/h5&gt;&lt;ul&gt;
&lt;li&gt;如PDA、智能手机&lt;/li&gt;
&lt;li&gt;CPU、内存和电源有限&lt;/li&gt;
&lt;li&gt;过去使用功能简化的OS&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;点对点计算&#34;&gt;点对点计算
&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;分布式系统的另一种模型&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;P2P不区分客户端和服务器&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;所有节点都被视为对等体&lt;/li&gt;
&lt;li&gt;可以充当客户端、服务器或两者&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;节点必须加入P2P网络&lt;/strong&gt;：
&lt;ul&gt;
&lt;li&gt;向中央查找服务注册其服务，或&lt;/li&gt;
&lt;li&gt;通过发现协议广播请求和响应服务&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;示例&lt;/strong&gt;：BitTorrent、Napster、Gnutella和区块链平台&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h3 id=&#34;操作系统操作&#34;&gt;操作系统操作
&lt;/h3&gt;&lt;h4 id=&#34;多道程序设计multiprogramming&#34;&gt;多道程序设计(Multiprogramming)
&lt;/h4&gt;&lt;h5 id=&#34;基本概念&#34;&gt;基本概念
&lt;/h5&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;多道程序设计&lt;/strong&gt;对于效率是必要的&lt;/li&gt;
&lt;li&gt;单个用户无法始终保持CPU和I/O设备忙碌&lt;/li&gt;
&lt;li&gt;用户的计算任务被组织为&lt;strong&gt;作业&lt;/strong&gt;(代码和数据)&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&#34;工作机制&#34;&gt;工作机制
&lt;/h5&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;作业调度&lt;/strong&gt;：内核调度作业，使CPU始终有事可做&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;内存管理&lt;/strong&gt;：系统中作业的子集保存在内存中&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;作业切换&lt;/strong&gt;：当作业必须等待(如I/O)时，内核切换到另一个作业&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;多任务multitasking&#34;&gt;多任务(Multitasking)
&lt;/h4&gt;&lt;h5 id=&#34;时间共享概念&#34;&gt;时间共享概念
&lt;/h5&gt;&lt;ul&gt;
&lt;li&gt;**时间共享(多任务)**扩展了多道程序设计&lt;/li&gt;
&lt;li&gt;OS频繁切换作业，用户可以与每个正在运行的作业交互&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;响应时间&lt;/strong&gt;应该&amp;lt; 1秒&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&#34;特征&#34;&gt;特征
&lt;/h5&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;每个用户&lt;/strong&gt;至少有一个程序在内存中执行(&lt;strong&gt;进程&lt;/strong&gt;)&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;CPU调度&lt;/strong&gt;：如果几个作业同时准备运行&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;虚拟/物理内存&lt;/strong&gt;：使程序员更容易&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;双模式操作&#34;&gt;双模式操作
&lt;/h4&gt;&lt;h5 id=&#34;基本概念-1&#34;&gt;基本概念
&lt;/h5&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;操作系统通常是中断驱动的&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;效率&lt;/strong&gt;，重新获得控制(定时器中断)&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;双模式操作&lt;/strong&gt;允许OS保护自身和其他系统组件&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&#34;模式类型&#34;&gt;模式类型
&lt;/h5&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;用户模式&lt;/strong&gt;和&lt;strong&gt;内核模式&lt;/strong&gt;(或其他名称)&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;模式位&lt;/strong&gt;区分CPU是在运行用户代码还是内核代码&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;特权指令&lt;/strong&gt;：一些指令被指定为特权的，只能在内核中执行&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;系统调用&lt;/strong&gt;：将模式改为内核，从调用返回将其重置为用户&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&#34;模式间转换&#34;&gt;模式间转换
&lt;/h5&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;系统调用、异常、中断&lt;/strong&gt;导致内核/用户模式之间的转换&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;定时器timer&#34;&gt;定时器(Timer)
&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;防止无限循环&lt;/strong&gt;或进程占用资源&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;启用定时器&lt;/strong&gt;：设置硬件在某个时间段后中断&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;OS设置定时器&lt;/strong&gt;：在调度进程之前设置定时器以重新获得控制&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;调度定时器&lt;/strong&gt;：通常是周期性的(如250Hz)&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;无滴答内核&lt;/strong&gt;：按需定时器中断(Linux)&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h3 id=&#34;资源管理&#34;&gt;资源管理
&lt;/h3&gt;&lt;h4 id=&#34;进程管理&#34;&gt;进程管理
&lt;/h4&gt;&lt;h5 id=&#34;进程基本概念&#34;&gt;进程基本概念
&lt;/h5&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;进程&lt;/strong&gt;是正在执行的程序
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;程序&lt;/strong&gt;是被动实体，&lt;strong&gt;进程&lt;/strong&gt;是活动实体&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;系统有许多进程并发运行&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&#34;从程序到进程&#34;&gt;从程序到进程
&lt;/h5&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;程序&lt;/strong&gt;：存储在磁盘上的被动代码&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;进程&lt;/strong&gt;：程序装载到内存后的活动实体&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;进程需要资源&lt;/strong&gt;来完成其任务：
&lt;ul&gt;
&lt;li&gt;CPU、内存、I/O、文件、初始化数据等&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;资源回收&lt;/strong&gt;：进程终止时，OS回收所有可重用资源&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&#34;进程管理活动&#34;&gt;进程管理活动
&lt;/h5&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;进程创建和终止&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;进程挂起和恢复&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;进程同步原语&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;进程通信原语&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;死锁处理&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&#34;从进程到线程&#34;&gt;从进程到线程
&lt;/h5&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;单线程进程&lt;/strong&gt;有一个程序计数器
&lt;ul&gt;
&lt;li&gt;程序计数器指定下一条要执行的指令的位置&lt;/li&gt;
&lt;li&gt;处理器按顺序执行指令，一次一条，直到完成&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;多线程进程&lt;/strong&gt;每个线程有一个程序计数器&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;线程的好处&lt;/strong&gt;：
&lt;ul&gt;
&lt;li&gt;创建开销小&lt;/li&gt;
&lt;li&gt;上下文切换快&lt;/li&gt;
&lt;li&gt;共享内存空间&lt;/li&gt;
&lt;li&gt;并发执行&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;内存管理&#34;&gt;内存管理
&lt;/h4&gt;&lt;h5 id=&#34;内存管理基本概念&#34;&gt;内存管理基本概念
&lt;/h5&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;内存&lt;/strong&gt;是CPU可直接访问的主要存储&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;数据处理前后&lt;/strong&gt;都需要保存在内存中&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;所有指令&lt;/strong&gt;都应该在内存中才能执行&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&#34;内存管理目标&#34;&gt;内存管理目标
&lt;/h5&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;优化CPU利用率和响应时间&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;为程序员提供虚拟内存视图&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&#34;内存管理活动&#34;&gt;内存管理活动
&lt;/h5&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;跟踪&lt;/strong&gt;内存的哪些部分正在被使用以及被谁使用&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;决定&lt;/strong&gt;哪些进程和数据移入和移出内存&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;分配和释放&lt;/strong&gt;根据需要分配和释放内存空间&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;文件系统管理&#34;&gt;文件系统管理
&lt;/h4&gt;&lt;h5 id=&#34;文件系统基本概念&#34;&gt;文件系统基本概念
&lt;/h5&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;OS提供统一的逻辑数据存储视图&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;文件&lt;/strong&gt;是抽象物理属性的逻辑存储单元&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;文件&lt;/strong&gt;通常组织到&lt;strong&gt;目录&lt;/strong&gt;中&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;访问控制&lt;/strong&gt;决定谁可以访问文件&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&#34;文件系统管理活动&#34;&gt;文件系统管理活动
&lt;/h5&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;创建和删除&lt;/strong&gt;文件和目录&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;操作原语&lt;/strong&gt;来操作文件和目录&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;映射文件&lt;/strong&gt;到辅助存储&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;备份文件&lt;/strong&gt;到稳定(非易失性)存储介质&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;大容量存储管理&#34;&gt;大容量存储管理
&lt;/h4&gt;&lt;h5 id=&#34;基本概念-2&#34;&gt;基本概念
&lt;/h5&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;磁盘子系统&lt;/strong&gt;管理大容量存储&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;磁盘用于存储&lt;/strong&gt;：
&lt;ul&gt;
&lt;li&gt;不适合主内存的数据&lt;/li&gt;
&lt;li&gt;必须保存&amp;quot;长&amp;quot;时间的数据&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;整个系统速度&lt;/strong&gt;取决于磁盘子系统及其算法&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;某些存储不需要快速&lt;/strong&gt;(如光存储或磁带)&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&#34;大容量存储管理活动&#34;&gt;大容量存储管理活动
&lt;/h5&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;空闲空间管理&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;存储分配&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;磁盘调度&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&#34;数据迁移通过存储层&#34;&gt;数据迁移通过存储层
&lt;/h5&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;系统必须使用最新值&lt;/strong&gt;，无论它存储在哪里&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;多级数据一致性&lt;/strong&gt;：
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;多处理器的缓存一致性&lt;/strong&gt;(缓存窥探)：由硬件实现&lt;/li&gt;
&lt;li&gt;所有CPU在其缓存中都有最新值&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;多进程或多线程的同步&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;分布式环境情况更复杂&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;一个数据可能存在多个副本：如何同步更改？&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;io系统管理&#34;&gt;I/O系统管理
&lt;/h4&gt;&lt;h5 id=&#34;io子系统职责&#34;&gt;I/O子系统职责
&lt;/h5&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;I/O子系统&lt;/strong&gt;向用户隐藏硬件设备的特性&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;I/O子系统负责&lt;/strong&gt;：
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;管理I/O内存&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;缓冲&lt;/strong&gt;：在数据传输时临时存储数据&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;缓存&lt;/strong&gt;：在更快存储中存储数据部分以提高性能&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;假脱机&lt;/strong&gt;：一个作业的输出与其他作业的输入重叠&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&#34;设备驱动程序接口&#34;&gt;设备驱动程序接口
&lt;/h5&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;OS可能提供通用设备驱动程序接口&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;优点&lt;/strong&gt;：对程序员好：面向对象设计模式&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;缺点&lt;/strong&gt;：从安全角度看：大量使用函数指针&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h3 id=&#34;操作系统设计原则&#34;&gt;操作系统设计原则
&lt;/h3&gt;&lt;h4 id=&#34;策略与机制分离&#34;&gt;策略与机制分离
&lt;/h4&gt;&lt;h5 id=&#34;基本概念-3&#34;&gt;基本概念
&lt;/h5&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;机制(Mechanism)&lt;/strong&gt;：关于系统&amp;quot;如何&amp;quot;的问题
&lt;ul&gt;
&lt;li&gt;操作系统如何执行上下文切换&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;策略(Policy)&lt;/strong&gt;：&amp;ldquo;哪个&amp;quot;问题
&lt;ul&gt;
&lt;li&gt;应该切换到哪个进程&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&#34;其他示例&#34;&gt;其他示例
&lt;/h5&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;机制示例&lt;/strong&gt;：
&lt;ul&gt;
&lt;li&gt;如何分配内存&lt;/li&gt;
&lt;li&gt;如何调度CPU&lt;/li&gt;
&lt;li&gt;如何处理中断&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;策略示例&lt;/strong&gt;：
&lt;ul&gt;
&lt;li&gt;哪个进程获得内存&lt;/li&gt;
&lt;li&gt;哪个进程优先运行&lt;/li&gt;
&lt;li&gt;哪个中断优先处理&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&#34;优势与劣势&#34;&gt;优势与劣势
&lt;/h5&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;优势&lt;/strong&gt;：
&lt;ul&gt;
&lt;li&gt;灵活性：可以更改策略而不改变机制&lt;/li&gt;
&lt;li&gt;模块化：清晰的分层设计&lt;/li&gt;
&lt;li&gt;可维护性：更容易理解和修改&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;劣势&lt;/strong&gt;：
&lt;ul&gt;
&lt;li&gt;性能开销：额外的抽象层&lt;/li&gt;
&lt;li&gt;复杂性：需要更仔细的设计&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;虚拟化&#34;&gt;虚拟化
&lt;/h4&gt;&lt;h5 id=&#34;虚拟化概念&#34;&gt;虚拟化概念
&lt;/h5&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;抽象单个计算机的硬件&lt;/strong&gt;(CPU/内存/IO等)到不同环境&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;虚拟机&lt;/strong&gt;：提供与底层硬件相同接口的软件&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;好处&lt;/strong&gt;：
&lt;ul&gt;
&lt;li&gt;资源共享&lt;/li&gt;
&lt;li&gt;隔离性&lt;/li&gt;
&lt;li&gt;可移植性&lt;/li&gt;
&lt;li&gt;易于管理&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&#34;虚拟化类型&#34;&gt;虚拟化类型
&lt;/h5&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;完全虚拟化&lt;/strong&gt;：完全模拟硬件&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;半虚拟化&lt;/strong&gt;：修改客户OS以与虚拟机监控器协作&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;硬件辅助虚拟化&lt;/strong&gt;：硬件支持虚拟化&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;抽象&#34;&gt;抽象
&lt;/h4&gt;&lt;h5 id=&#34;抽象的重要性&#34;&gt;抽象的重要性
&lt;/h5&gt;&lt;p&gt;&lt;strong&gt;抽象是我们在计算机科学中所做的一切的基础&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;抽象使以下成为可能：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;编写大型程序&lt;/strong&gt;：将其分为小而可理解的片段&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;使用高级语言&lt;/strong&gt;：如C语言编写而不考虑汇编&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;汇编编程&lt;/strong&gt;：而不考虑逻辑门&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;构建处理器&lt;/strong&gt;：使用门而不过多考虑晶体管&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&#34;抽象层次&#34;&gt;抽象层次
&lt;/h5&gt;&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;应用程序层&lt;/strong&gt;：用户程序&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;高级语言层&lt;/strong&gt;：C/C++/Java等&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;汇编语言层&lt;/strong&gt;：汇编指令&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;指令集架构层&lt;/strong&gt;：机器指令&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;微架构层&lt;/strong&gt;：CPU内部实现&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;逻辑门层&lt;/strong&gt;：数字逻辑&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;晶体管层&lt;/strong&gt;：物理实现&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;
&lt;h2 id=&#34;操作系统框架&#34;&gt;操作系统框架
&lt;/h2&gt;&lt;h3 id=&#34;操作系统服务组成&#34;&gt;操作系统服务组成
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;用户可见服务
&lt;ul&gt;
&lt;li&gt;用户界面(UI)
&lt;ul&gt;
&lt;li&gt;包括：CLI(Command-Line, 命令行), GUI(Graphic User Line, 图形化用户界面), batch&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;程序运行&lt;/li&gt;
&lt;li&gt;I/O操作&lt;/li&gt;
&lt;li&gt;文件系统操作&lt;/li&gt;
&lt;li&gt;通信&lt;/li&gt;
&lt;li&gt;错误检测&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;系统可见服务
&lt;ul&gt;
&lt;li&gt;资源分配
&lt;ul&gt;
&lt;li&gt;包括：CPU调度，内存分配和管理，I/O设备分配&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;系统保护&lt;/li&gt;
&lt;li&gt;会计统计&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;系统调用system-call&#34;&gt;系统调用(System Call)
&lt;/h3&gt;&lt;h4 id=&#34;定义&#34;&gt;定义
&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;系统调用指的是访问操作系统服务的编程接口&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;示例&#34;&gt;示例
&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;Linux的复制指令
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;cp in.txt out.txt
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;就是一个调用系统调用&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;调用&#34;&gt;调用
&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;一般一个系统调用被与一个数字联系起来，这个数字被称为&lt;strong&gt;系统调用号(System Call Number)&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;例如Linux中read()可能是编号0，write()可能是编号1&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;系统调用接口表
&lt;ul&gt;
&lt;li&gt;系统调用接口维护着一个表格，这个表格被这些编号索引，表格中存储着对应系统调用处理函数的地址，类似于您文档中提到的中断向量表观念&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Linux系统调用数量示例
&lt;ul&gt;
&lt;li&gt;Linux有大约340个系统调用，不同架构的系统调用数量略有差异。x86架构有349个系统调用，而ARM架构有345个&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;系统调用的核心原理&#34;&gt;系统调用的核心原理
&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;内核执行系统调用并返回结果&lt;/li&gt;
&lt;li&gt;用户程序无需了解系统调用细节&lt;/li&gt;
&lt;li&gt;用户只需使用API并理解其功能&lt;/li&gt;
&lt;li&gt;API隐藏操作系统接口的大部分细节&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;系统调用传参&#34;&gt;系统调用传参
&lt;/h4&gt;&lt;h5 id=&#34;寄存器法&#34;&gt;寄存器法
&lt;/h5&gt;&lt;ul&gt;
&lt;li&gt;工作原理
&lt;ul&gt;
&lt;li&gt;参数直接存储在CPU寄存器中&lt;/li&gt;
&lt;li&gt;系统调用时，内核直接从寄存器读取参数&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;优势
&lt;ul&gt;
&lt;li&gt;速度最快&lt;/li&gt;
&lt;li&gt;实现简单&lt;/li&gt;
&lt;li&gt;开销最小&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;劣势
&lt;ul&gt;
&lt;li&gt;参数数量首先&lt;/li&gt;
&lt;li&gt;不适合复杂调用&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;内存块法&lt;/li&gt;
&lt;li&gt;工作原理
&lt;ul&gt;
&lt;li&gt;参数存储在内存块（或表）中&lt;/li&gt;
&lt;li&gt;内存块的地址作为参数传递给寄存器&lt;/li&gt;
&lt;li&gt;内核通过地址访问内存块获取所有参数&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;优势
&lt;ul&gt;
&lt;li&gt;参数数量不受限制：内存块可以很大&lt;/li&gt;
&lt;li&gt;适合复杂数据结构：可以传递结构体、数组等&lt;/li&gt;
&lt;li&gt;组织性好：参数集中管理&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;劣势
&lt;ul&gt;
&lt;li&gt;需要额外内存访问&lt;/li&gt;
&lt;li&gt;实现稍复杂&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;栈法
&lt;ul&gt;
&lt;li&gt;工作原理
&lt;ul&gt;
&lt;li&gt;参数被程序推入栈中&lt;/li&gt;
&lt;li&gt;操作系统从栈中弹出参数&lt;/li&gt;
&lt;li&gt;利用栈的后进先出特性&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;优势
&lt;ul&gt;
&lt;li&gt;参数数量不受限制&lt;/li&gt;
&lt;li&gt;自然的调用约定&lt;/li&gt;
&lt;li&gt;易于实现&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;劣势
&lt;ul&gt;
&lt;li&gt;栈操作开销&lt;/li&gt;
&lt;li&gt;栈空间管理&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&#34;linuxx86架构下execve系统调用的实现&#34;&gt;Linux/x86架构下execve系统调用的实现
&lt;/h5&gt;&lt;ul&gt;
&lt;li&gt;存储系统调用信号到eax寄存器&lt;/li&gt;
&lt;li&gt;参数存储到指定寄存器&lt;/li&gt;
&lt;li&gt;执行系统调用指令&lt;/li&gt;
&lt;li&gt;完整汇编代码如下
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;19
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;20
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;21
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-asm&#34; data-lang=&#34;asm&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nf&#34;&gt;section&lt;/span&gt; &lt;span class=&#34;no&#34;&gt;.data&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;nf&#34;&gt;filename&lt;/span&gt; &lt;span class=&#34;no&#34;&gt;db&lt;/span&gt; &lt;span class=&#34;err&#34;&gt;&amp;#39;/&lt;/span&gt;&lt;span class=&#34;no&#34;&gt;bin&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;/&lt;/span&gt;&lt;span class=&#34;no&#34;&gt;ls&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;nf&#34;&gt;arg1&lt;/span&gt; &lt;span class=&#34;no&#34;&gt;db&lt;/span&gt; &lt;span class=&#34;err&#34;&gt;&amp;#39;&lt;/span&gt;&lt;span class=&#34;no&#34;&gt;ls&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;nf&#34;&gt;arg2&lt;/span&gt; &lt;span class=&#34;no&#34;&gt;db&lt;/span&gt; &lt;span class=&#34;err&#34;&gt;&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;no&#34;&gt;l&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;nf&#34;&gt;argv&lt;/span&gt; &lt;span class=&#34;no&#34;&gt;dd&lt;/span&gt; &lt;span class=&#34;no&#34;&gt;filename&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;no&#34;&gt;arg1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;no&#34;&gt;arg2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;nf&#34;&gt;envp&lt;/span&gt; &lt;span class=&#34;no&#34;&gt;dd&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nf&#34;&gt;section&lt;/span&gt; &lt;span class=&#34;no&#34;&gt;.text&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;nf&#34;&gt;global&lt;/span&gt; &lt;span class=&#34;no&#34;&gt;_start&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nl&#34;&gt;_start:&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;nf&#34;&gt;mov&lt;/span&gt; &lt;span class=&#34;no&#34;&gt;eax&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;11&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;nf&#34;&gt;mov&lt;/span&gt; &lt;span class=&#34;no&#34;&gt;ebx&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;no&#34;&gt;filename&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;nf&#34;&gt;mov&lt;/span&gt; &lt;span class=&#34;no&#34;&gt;ecx&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;no&#34;&gt;argv&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;nf&#34;&gt;mov&lt;/span&gt; &lt;span class=&#34;no&#34;&gt;edx&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;no&#34;&gt;envp&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;nf&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0x80&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;nf&#34;&gt;mov&lt;/span&gt; &lt;span class=&#34;no&#34;&gt;eax&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;nf&#34;&gt;mov&lt;/span&gt; &lt;span class=&#34;no&#34;&gt;ebx&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;nf&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0x80&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;系统调用列举&#34;&gt;系统调用列举
&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;进程控制
&lt;ul&gt;
&lt;li&gt;Types of System Calls&lt;/li&gt;
&lt;li&gt;Process control&lt;/li&gt;
&lt;li&gt;create process, terminate process&lt;/li&gt;
&lt;li&gt;end, abort&lt;/li&gt;
&lt;li&gt;load, execute&lt;/li&gt;
&lt;li&gt;get process attributes, set process attributes&lt;/li&gt;
&lt;li&gt;wait for time&lt;/li&gt;
&lt;li&gt;wait event, signal event&lt;/li&gt;
&lt;li&gt;allocate and free memory&lt;/li&gt;
&lt;li&gt;Dump memory if error&lt;/li&gt;
&lt;li&gt;Debugger for determining bugs, single step execution&lt;/li&gt;
&lt;li&gt;Locks for managing access to shared data between processes&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;文件管理
&lt;ul&gt;
&lt;li&gt;create file, delete file&lt;/li&gt;
&lt;li&gt;open, close file&lt;/li&gt;
&lt;li&gt;read, write, reposition&lt;/li&gt;
&lt;li&gt;get and set file attributes&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;设备管理
&lt;ul&gt;
&lt;li&gt;request device, release device&lt;/li&gt;
&lt;li&gt;read, write, reposition&lt;/li&gt;
&lt;li&gt;get device attributes, set device attributes&lt;/li&gt;
&lt;li&gt;logically attach or detach devices&lt;/li&gt;
&lt;li&gt;can be combined with file management system call&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;信息维护
&lt;ul&gt;
&lt;li&gt;get time or date, set time or date&lt;/li&gt;
&lt;li&gt;get system data, set system data&lt;/li&gt;
&lt;li&gt;get and set process, file, or device attributes&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;通信
&lt;ul&gt;
&lt;li&gt;create, delete communication connection&lt;/li&gt;
&lt;li&gt;send, receive messages: message passing model to host name or process name
&lt;ul&gt;
&lt;li&gt;From client to server&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Shared-memory model create and gain access to memory regions&lt;/li&gt;
&lt;li&gt;transfer status information&lt;/li&gt;
&lt;li&gt;attach and detach remote devices&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;保护
&lt;ul&gt;
&lt;li&gt;Control access to resources&lt;/li&gt;
&lt;li&gt;Get and set permissions&lt;/li&gt;
&lt;li&gt;Allow and deny user access&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;应用程序接口application-programming-interface-api&#34;&gt;应用程序接口(Application Programming Interface, API)
&lt;/h4&gt;&lt;h5 id=&#34;定义-1&#34;&gt;定义：
&lt;/h5&gt;&lt;ul&gt;
&lt;li&gt;应用程序编程接口，是预先定义的函数/集合的集合&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&#34;常用的api&#34;&gt;常用的API
&lt;/h5&gt;&lt;ul&gt;
&lt;li&gt;Win32： Windows&lt;/li&gt;
&lt;li&gt;POSIX： UNIX, Linux&lt;/li&gt;
&lt;li&gt;Java: Java虚拟机&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;链接器linker与加载器loader&#34;&gt;链接器(Linker)与加载器(Loader)
&lt;/h2&gt;&lt;h3 id=&#34;基本概念-4&#34;&gt;基本概念
&lt;/h3&gt;&lt;h4 id=&#34;链接器&#34;&gt;链接器
&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;功能：将目标文件转换为可执行文件&lt;/li&gt;
&lt;li&gt;作用：解决符号引用，合并代码段和数据段、&lt;/li&gt;
&lt;li&gt;时机：编译时或程序启动时&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;加载器&#34;&gt;加载器
&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;功能：将程序转换为进程&lt;/li&gt;
&lt;li&gt;作用：将可执行文件加载到内存并启动执行&lt;/li&gt;
&lt;li&gt;时机：程序执行时&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;工作方式和内容&#34;&gt;工作方式和内容
&lt;/h4&gt;&lt;h5 id=&#34;编译链接过程&#34;&gt;编译链接过程
&lt;/h5&gt;&lt;p align=&#34;center&#34;&gt;
    &lt;img src=&#34;images/os1.png&#34; alt=&#34;编译过程&#34; width=&#34;100%&#34;&gt;
&lt;/p&gt;
&lt;h5 id=&#34;链接类型对比&#34;&gt;链接类型对比
&lt;/h5&gt;&lt;ul&gt;
&lt;li&gt;静态链接
&lt;ul&gt;
&lt;li&gt;特点
&lt;ul&gt;
&lt;li&gt;链接时机：编译时完成所有链接&lt;/li&gt;
&lt;li&gt;文件大小：较大，包含所有依赖库&lt;/li&gt;
&lt;li&gt;运行依赖：无外部依赖，独立运行&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;优点
&lt;ul&gt;
&lt;li&gt;运行时无依赖&lt;/li&gt;
&lt;li&gt;加载速度快&lt;/li&gt;
&lt;li&gt;部署简单&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;缺点
&lt;ul&gt;
&lt;li&gt;文件体积大&lt;/li&gt;
&lt;li&gt;内存占用多&lt;/li&gt;
&lt;li&gt;库更新需要重新编译&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;动态链接
&lt;ul&gt;
&lt;li&gt;特点
&lt;ul&gt;
&lt;li&gt;链接时机：运行时动态链接&lt;/li&gt;
&lt;li&gt;文件大小：较小，只包含引用信息&lt;/li&gt;
&lt;li&gt;运行依赖：需要动态链接库(DLL/SO)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;优点：
&lt;ul&gt;
&lt;li&gt;文件体积小&lt;/li&gt;
&lt;li&gt;内存共享&lt;/li&gt;
&lt;li&gt;库更新无需重新编译&lt;/li&gt;
&lt;li&gt;节省磁盘空间&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;缺点：
&lt;ul&gt;
&lt;li&gt;运行时有依赖&lt;/li&gt;
&lt;li&gt;加载稍慢&lt;/li&gt;
&lt;li&gt;部署复杂&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;注：延迟绑定(Lazy Binding)
&lt;ul&gt;
&lt;li&gt;概念
&lt;ul&gt;
&lt;li&gt;定义：动态链接库中的函数在第一次调用时才进行地址解析&lt;/li&gt;
&lt;li&gt;目的：减少程序启动时间，只解析实际使用的函数&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;操作系统架构&#34;&gt;操作系统架构
&lt;/h2&gt;&lt;h3 id=&#34;已有的操作系统架构&#34;&gt;已有的操作系统架构
&lt;/h3&gt;&lt;h4 id=&#34;ms-dos&#34;&gt;MS-DOS
&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;架构特点&lt;/strong&gt;：简单的单体结构&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;特征&lt;/strong&gt;：
&lt;ul&gt;
&lt;li&gt;应用程序可以直接访问硬件&lt;/li&gt;
&lt;li&gt;没有明确的用户模式和内核模式分离&lt;/li&gt;
&lt;li&gt;程序运行在单一地址空间&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;优点&lt;/strong&gt;：
&lt;ul&gt;
&lt;li&gt;系统开销小&lt;/li&gt;
&lt;li&gt;执行效率高&lt;/li&gt;
&lt;li&gt;实现简单&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;缺点&lt;/strong&gt;：
&lt;ul&gt;
&lt;li&gt;系统不稳定，一个程序崩溃可能导致整个系统崩溃&lt;/li&gt;
&lt;li&gt;安全性差&lt;/li&gt;
&lt;li&gt;不支持多任务&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;original-unix&#34;&gt;Original-UNIX
&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;架构特点&lt;/strong&gt;：经典的分层单体内核&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;特征&lt;/strong&gt;：
&lt;ul&gt;
&lt;li&gt;内核和用户程序分离&lt;/li&gt;
&lt;li&gt;系统调用作为内核和用户程序的接口&lt;/li&gt;
&lt;li&gt;&amp;ldquo;一切皆文件&amp;quot;的设计理念&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;优点&lt;/strong&gt;：
&lt;ul&gt;
&lt;li&gt;简洁而强大的设计&lt;/li&gt;
&lt;li&gt;良好的可移植性&lt;/li&gt;
&lt;li&gt;多用户多任务支持&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;缺点&lt;/strong&gt;：
&lt;ul&gt;
&lt;li&gt;内核代码耦合度高&lt;/li&gt;
&lt;li&gt;难以扩展和维护&lt;/li&gt;
&lt;li&gt;单体内核的性能瓶颈&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;分层方法layered-approach&#34;&gt;分层方法(Layered Approach)
&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;基本概念&lt;/strong&gt;：
&lt;ul&gt;
&lt;li&gt;操作系统被划分为多个层次(levels)&lt;/li&gt;
&lt;li&gt;每一层都建立在较低层之上&lt;/li&gt;
&lt;li&gt;最底层(第0层)是硬件，最高层(第N层)是用户界面&lt;/li&gt;
&lt;li&gt;每一层只使用较低层的函数和服务&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;THE操作系统分层示例&lt;/strong&gt;：
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;6
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;第5层: 用户程序
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;第4层: 输入/输出管理
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;第3层: 操作员-进程通信
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;第2层: 内存管理
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;第1层: 进程调度
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;第0层: 硬件
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;优点&lt;/strong&gt;：
&lt;ul&gt;
&lt;li&gt;模块化设计，便于调试和维护&lt;/li&gt;
&lt;li&gt;层次清晰，易于理解&lt;/li&gt;
&lt;li&gt;易于验证系统正确性&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;缺点&lt;/strong&gt;：
&lt;ul&gt;
&lt;li&gt;性能开销大(多层调用)&lt;/li&gt;
&lt;li&gt;层次划分困难&lt;/li&gt;
&lt;li&gt;严格分层限制系统灵活性&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;微内核方法microkernel-approach&#34;&gt;微内核方法(Microkernel Approach)
&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;基本概念&lt;/strong&gt;：
&lt;ul&gt;
&lt;li&gt;将尽可能多的功能从内核移到用户空间&lt;/li&gt;
&lt;li&gt;内核只保留最基本的功能&lt;/li&gt;
&lt;li&gt;其他系统服务作为用户级进程运行&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;微内核核心功能&lt;/strong&gt;：
&lt;ul&gt;
&lt;li&gt;进程间通信(IPC)&lt;/li&gt;
&lt;li&gt;基本进程管理&lt;/li&gt;
&lt;li&gt;低级内存管理&lt;/li&gt;
&lt;li&gt;基本I/O和中断管理&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;用户空间服务&lt;/strong&gt;：
&lt;ul&gt;
&lt;li&gt;文件系统服务器&lt;/li&gt;
&lt;li&gt;网络协议栈&lt;/li&gt;
&lt;li&gt;设备驱动程序&lt;/li&gt;
&lt;li&gt;虚拟内存管理器&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;优点&lt;/strong&gt;：
&lt;ul&gt;
&lt;li&gt;系统稳定性高(服务崩溃不影响内核)&lt;/li&gt;
&lt;li&gt;安全性好(服务运行在隔离的地址空间)&lt;/li&gt;
&lt;li&gt;易于扩展和维护&lt;/li&gt;
&lt;li&gt;支持分布式系统&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;缺点&lt;/strong&gt;：
&lt;ul&gt;
&lt;li&gt;IPC开销大，性能较低&lt;/li&gt;
&lt;li&gt;系统调用开销增加&lt;/li&gt;
&lt;li&gt;设计和实现复杂&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;模块化方法modular-approach&#34;&gt;模块化方法(Modular Approach)
&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;基本概念&lt;/strong&gt;：
&lt;ul&gt;
&lt;li&gt;结合单体内核和微内核的优点&lt;/li&gt;
&lt;li&gt;内核提供核心服务&lt;/li&gt;
&lt;li&gt;其他功能通过可装载模块实现&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;特征&lt;/strong&gt;：
&lt;ul&gt;
&lt;li&gt;模块可以动态加载和卸载&lt;/li&gt;
&lt;li&gt;模块运行在内核空间&lt;/li&gt;
&lt;li&gt;通过定义良好的接口通信&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Linux模块示例&lt;/strong&gt;：
&lt;ul&gt;
&lt;li&gt;文件系统模块(ext4, ntfs)&lt;/li&gt;
&lt;li&gt;网络协议模块(TCP/IP)&lt;/li&gt;
&lt;li&gt;设备驱动模块&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;优点&lt;/strong&gt;：
&lt;ul&gt;
&lt;li&gt;灵活性高&lt;/li&gt;
&lt;li&gt;内存使用效率高&lt;/li&gt;
&lt;li&gt;易于维护和扩展&lt;/li&gt;
&lt;li&gt;性能好(避免用户空间切换)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;缺点&lt;/strong&gt;：
&lt;ul&gt;
&lt;li&gt;模块错误可能影响整个内核&lt;/li&gt;
&lt;li&gt;接口设计需要谨慎&lt;/li&gt;
&lt;li&gt;依赖关系管理复杂&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;混合系统架构&#34;&gt;混合系统架构
&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;基本概念&lt;/strong&gt;：
&lt;ul&gt;
&lt;li&gt;结合多种架构方法的优点&lt;/li&gt;
&lt;li&gt;针对不同功能采用最适合的架构&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;现代操作系统实例&lt;/strong&gt;：
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Windows NT&lt;/strong&gt;：混合微内核架构
&lt;ul&gt;
&lt;li&gt;内核模式：HAL、内核、执行体&lt;/li&gt;
&lt;li&gt;用户模式：子系统、应用程序&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;macOS&lt;/strong&gt;：基于Mach微内核的混合架构
&lt;ul&gt;
&lt;li&gt;Mach微内核 + BSD层 + I/O Kit&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Linux&lt;/strong&gt;：模块化单体内核
&lt;ul&gt;
&lt;li&gt;单体内核 + 可装载模块&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;系统调用实例&#34;&gt;系统调用实例
&lt;/h3&gt;&lt;h4 id=&#34;进程管理系统调用示例&#34;&gt;进程管理系统调用示例
&lt;/h4&gt;&lt;h5 id=&#34;fork系统调用&#34;&gt;fork系统调用
&lt;/h5&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;基本概念&lt;/strong&gt;：创建新进程的方式&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;特殊之处&lt;/strong&gt;：
&lt;ul&gt;
&lt;li&gt;新创建的进程是调用进程的完全副本&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;返回两次&lt;/strong&gt;：在父进程和子进程中分别返回&lt;/li&gt;
&lt;li&gt;新进程拥有自己的内存地址空间&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;返回值&lt;/strong&gt;：
&lt;ul&gt;
&lt;li&gt;在父进程中：返回子进程的PID&lt;/li&gt;
&lt;li&gt;在子进程中：返回0&lt;/li&gt;
&lt;li&gt;出错时：返回-1&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&#34;fork--wait组合&#34;&gt;fork + wait组合
&lt;/h5&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;wait系统调用&lt;/strong&gt;：父进程等待子进程执行完毕&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;用途&lt;/strong&gt;：
&lt;ul&gt;
&lt;li&gt;避免僵尸进程&lt;/li&gt;
&lt;li&gt;获取子进程退出状态&lt;/li&gt;
&lt;li&gt;进程同步控制&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;典型使用模式&lt;/strong&gt;：
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;8
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kt&#34;&gt;pid_t&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;pid&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;fork&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;();&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;pid&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;==&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;c1&#34;&gt;// 子进程代码
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;nf&#34;&gt;exit&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;else&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;pid&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;c1&#34;&gt;// 父进程代码
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;nf&#34;&gt;wait&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nb&#34;&gt;NULL&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;  &lt;span class=&#34;c1&#34;&gt;// 等待子进程结束
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&#34;fork--wait--exec组合&#34;&gt;fork + wait + exec组合
&lt;/h5&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;exec系统调用特点&lt;/strong&gt;：
&lt;ul&gt;
&lt;li&gt;用于运行与调用程序不同的程序&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;exec永不返回&lt;/strong&gt;(成功时)&lt;/li&gt;
&lt;li&gt;完全替换当前进程映像&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;为什么分离fork和exec&lt;/strong&gt;：
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;构建UNIX shell的基础&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;允许在fork后、exec前进行特殊操作&lt;/li&gt;
&lt;li&gt;提供更大的灵活性&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Shell工作原理&lt;/strong&gt;：
&lt;ul&gt;
&lt;li&gt;Shell是一个用户程序&lt;/li&gt;
&lt;li&gt;等待用户输入&lt;/li&gt;
&lt;li&gt;执行命令：fork创建子进程 → exec加载新程序 → wait等待完成&lt;/li&gt;
&lt;li&gt;分离设计使shell功能更强大&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;调试相关系统调用&#34;&gt;调试相关系统调用
&lt;/h4&gt;&lt;h5 id=&#34;ptrace系统调用&#34;&gt;ptrace系统调用
&lt;/h5&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;基本概念&lt;/strong&gt;：进程追踪系统调用&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;主要功能&lt;/strong&gt;：
&lt;ul&gt;
&lt;li&gt;一个进程可以控制另一个进程的执行&lt;/li&gt;
&lt;li&gt;检查和修改被追踪进程的内存和寄存器&lt;/li&gt;
&lt;li&gt;实现断点调试功能&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;应用场景&lt;/strong&gt;：
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;调试器实现&lt;/strong&gt;：gdb、strace等工具的基础&lt;/li&gt;
&lt;li&gt;进程监控和分析&lt;/li&gt;
&lt;li&gt;安全分析工具&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&#34;调试器debugger工作原理&#34;&gt;调试器(Debugger)工作原理
&lt;/h5&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;定义&lt;/strong&gt;：用于测试和调试其他程序的计算机程序&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;基本操作&lt;/strong&gt;：
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;附加到进程&lt;/strong&gt;(Attaching to a process)&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;基本控制&lt;/strong&gt;(Basic Control)：暂停、继续、单步执行&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;设置断点&lt;/strong&gt;(Setting a breakpoint)&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;命中断点&lt;/strong&gt;(Hitting a breakpoint)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;ptrace在调试中的应用&lt;/strong&gt;：
&lt;ul&gt;
&lt;li&gt;通过ptrace系统调用实现进程控制&lt;/li&gt;
&lt;li&gt;监控被调试程序的每个系统调用&lt;/li&gt;
&lt;li&gt;提供程序执行状态的实时查看&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;系统调用实践要点&#34;&gt;系统调用实践要点
&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;进程创建模式&lt;/strong&gt;：fork + exec是UNIX系统进程创建的标准模式&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Shell实现&lt;/strong&gt;：所有UNIX shell都基于fork/exec/wait三个系统调用&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;调试工具&lt;/strong&gt;：现代调试器和追踪工具都依赖ptrace系统调用&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;手册参考&lt;/strong&gt;：使用man page查看详细的系统调用文档和使用方法&lt;/li&gt;
&lt;/ul&gt;
</description>
        </item>
        
    </channel>
</rss>
